{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>FastJWT is a FastAPI Plugin for reusable JWT Authentication Management. fastjwt enables easy JSON Web Tokens management within your FastAPI application.</p> <p>fastjwt is heavily inspired from its Flask equivalent Flask-JWT-Extended, special thanks to @vimalloc fot the amazing work.</p> <p>Documentation: https://ocarinow.github.io/fastjwt/</p>"},{"location":"#features","title":"Features","text":"<ul> <li> Encode/Decode JWT for application Authentication</li> <li> Automatic JWT detection in request</li> <li> JWT in Headers</li> <li> JWT in Cookies</li> <li> JWT in Query strings</li> <li> JWT in JSON Body</li> <li> Implicit/Explicit token refresh mechanism</li> <li> Freshness state of token</li> <li> Route protection</li> <li> Token type based protection (access/refresh)</li> <li> Token freshness protection</li> <li> Partial route protection</li> <li> Handle custom user logic for revoked token validation</li> <li> Handle custom logic for token recipient retrieval (ORM, pydantic serialization...)</li> <li> Provide FastAPI compliant dependency injection API</li> <li> Automatic error handling</li> <li> Scope Management (WIP)</li> </ul>"},{"location":"#setup","title":"Setup","text":""},{"location":"#requirements","title":"Requirements","text":"<p>FastJWT is built on top of the following dependencies:</p> <ul> <li>FastAPI as web framework</li> <li>Pydantic as data validation</li> <li>PyJWT as python implementation of the JSON Web Token standard</li> </ul> <p>FastJWT also relies on <code>typing-extensions</code> for backward compatibility (python3.9)</p> <p>Note</p> <p>FastAPI, while required for fastjwt, is not declared as a dependency and must be installed prior with <code>pip install fastapi</code></p>"},{"location":"#install","title":"Install","text":"<pre><code># With pip\npip install fastjwt\n# With poetry\npoetry add fastjwt\n# With pipenv\npipenv install fastjwt\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom fastjwt import FastJWT\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@app.get('/login')\ndef login():\n    return security.create_access_token(uid='foo')\n\n@app.get('/protected', dependencies=[Depends(security.access_token_required())])\ndef protected():\n    return \"This is a protected endpoint\"\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>WORK IN PROGRESS</p> <p>The development guide is not available yet</p>"},{"location":"#contributing","title":"Contributing","text":"<p>WORK IN PROGRESS</p> <p>The contribution guide is not available yet</p>"},{"location":"#license","title":"License","text":"<p>This project is open source under MIT License</p>"},{"location":"claims/","title":"Claims","text":"<p>The JSON Web Tokens might contain the following claims (json keys). You can find additional details on the official standard specification. All the following claims are the standard JWT claims and are handled by fastjwt during execution. You must avoid interacting with these values manually.</p>"},{"location":"claims/#standard-jwt-claims","title":"Standard JWT Claims","text":""},{"location":"claims/#iss","title":"<code>iss</code>","text":"<p><code>Optional[str]</code></p> <p>Issuer claim identifying the principal that issued the JWT</p>"},{"location":"claims/#sub","title":"<code>sub</code>","text":"<p><code>Optional[str]</code></p> <p>Subject claim identifying the principal that is the subject of the JWT</p>"},{"location":"claims/#aud","title":"<code>aud</code>","text":"<p><code>Optional[str | List[str]]</code></p> <p>Audience claim identifying the recipients that the JWT is intended for.</p>"},{"location":"claims/#exp","title":"<code>exp</code>","text":"<p><code>Optional[float | int] as datetime</code></p> <p>Expiration Time claim identifying the datetime after which the JWT must NOT be accepted by the server.</p>"},{"location":"claims/#nbf","title":"<code>nbf</code>","text":"<p><code>Optional[float | int] as datetime</code></p> <p>Not Before claim identifying the datetime before which the JWT must NOT be accepted by the server.</p>"},{"location":"claims/#iat","title":"<code>iat</code>","text":"<p><code>Optional[float | int] as datetime</code></p> <p>Issued at claim identifying the datetime at which the JWT was issued.</p>"},{"location":"claims/#jti","title":"<code>jti</code>","text":"<p><code>Optional[str]</code></p> <p>JWT ID claim is a unique identifier for the JWT.</p>"},{"location":"claims/#fastjwt-claims","title":"FastJWT Claims","text":"<p>In addition to the standard claims fastjwt adds custom claims to handle the following features:</p> <ul> <li>Access/Refresh token specification</li> <li>CSRF protection for authentication with cookies</li> <li>Token freshness for operation where login step is required</li> <li>Scopes for privileges management</li> </ul> <p>Info on Scopes</p> <p>Scopes are not available in the current version of fastjwt. The claim exists in the <code>TokenPayload</code> object for next feature anticipation.</p>"},{"location":"claims/#fresh","title":"<code>fresh</code>","text":"<p><code>bool</code></p> <p>Claim to indicate if the token is fresh. Fresh token are usually required when sensitive operation are done by the user (e.g password update, privilege management...)</p>"},{"location":"claims/#csrf","title":"<code>csrf</code>","text":"<p><code>Optional[str]</code></p> <p>Claim containing a double submit token that must be compared to a request CSRF token when authenticating with cookies. Check Cross-Site Request Forgery for additional details.</p>"},{"location":"claims/#type","title":"<code>type</code>","text":"<p><code>Literal[\"access\"] | Literal[\"refresh\"]</code></p> <p>Claim identifying the type of the token. Some operation require refresh token -usually to refresh an access token- while other are strictly tied to access tokens</p>"},{"location":"claims/#scopes","title":"<code>scopes</code>","text":"<p><code>Optional[List[str]]</code></p> <p>Claim containing a list of permissions/privileges for additional route restriction. The system also allows for scoped rights on server.</p>"},{"location":"claims/#used-defined-claims","title":"Used defined claims","text":"<p>While JWTs should avoid containing sensitive information since JWTs are easyly readable (base64 encoded), you can provide additional data to a JWT.</p> <p>To add additional claims to a token use the <code>FastJWT.create_access_token</code> and <code>FastJWT.create_refresh_token</code> keyword arguments.</p> <pre><code>from fastjwt import FastJWT\nfrom fastjwt import TokenPayload\n\nsecurity = FastJWT(...)\ntoken = security.create_access_token(\"unique_identifier\", foo=\"bar\")\npayload = TokenPayload.decode(token, verify=False)\n\nprint(payload.sub)\n&gt;&gt;&gt; \"unique_identifier\"\nprint(payload.foo)\n&gt;&gt;&gt; \"bar\"\n</code></pre> <p>Reserved claims</p> <p>Do not use the standard claims as keyword arguments in the methods above to avoid undesired behavior</p> <p>JSON serializable python object</p> <p>Do not in order to encode a token the <code>json</code> package from the standard library is used.  Therefore, you won't be able to serialize object that are not supported by the <code>json</code> library</p> <pre><code>from fastjwt import FastJWT\nfrom fastjwt import TokenPayload\nfrom datetime import datetime\n\nsecurity = FastJWT(...)\n# The following lie will raise an error since datetime.datetime is not `json` serializable\ntoken = security.create_access_token(\"unique_identifier\", foo=datetime(2023, 1, 1, 12, 0))\n</code></pre>"},{"location":"config/","title":"Configuration","text":"<p>FastJWT options are inspired by vimalloc/flask-jwt-extended.</p> <ul> <li>Configuration</li> <li>Main options<ul> <li>JWT_ACCESS_TOKEN_EXPIRES</li> <li>JWT_ALGORITHM</li> <li>JWT_DECODE_AUDIENCE</li> <li>JWT_DECODE_ISSUER</li> <li>JWT_ENCODE_AUDIENCE</li> <li>JWT_ENCODE_ISSUER</li> <li>JWT_PRIVATE_KEY</li> <li>JWT_PUBLIC_KEY</li> <li>JWT_REFRESH_TOKEN_EXPIRES</li> <li>JWT_SECRET_KEY</li> <li>JWT_TOKEN_LOCATION</li> </ul> </li> <li>Header options<ul> <li>JWT_HEADER_NAME</li> <li>JWT_HEADER_TYPE</li> </ul> </li> <li>Cookie options<ul> <li>JWT_ACCESS_COOKIE_NAME</li> <li>JWT_ACCESS_COOKIE_PATH</li> <li>JWT_COOKIE_CSRF_PROTECT</li> <li>JWT_COOKIE_DOMAIN</li> <li>JWT_COOKIE_MAX_AGE</li> <li>JWT_COOKIE_SAMESITE</li> <li>JWT_COOKIE_SECURE</li> <li>JWT_REFRESH_COOKIE_NAME</li> <li>JWT_REFRESH_COOKIE_PATH</li> </ul> </li> <li>CSRF options<ul> <li>JWT_ACCESS_CSRF_COOKIE_NAME</li> <li>JWT_ACCESS_CSRF_COOKIE_PATH</li> <li>JWT_ACCESS_CSRF_FIELD_NAME</li> <li>JWT_ACCESS_CSRF_HEADER_NAME</li> <li>JWT_CSRF_CHECK_FORM</li> <li>JWT_CSRF_IN_COOKIES</li> <li>JWT_CSRF_METHODS</li> <li>JWT_REFRESH_CSRF_COOKIE_NAME</li> <li>JWT_REFRESH_CSRF_COOKIE_PATH</li> <li>JWT_REFRESH_CSRF_FIELD_NAME</li> <li>JWT_REFRESH_CSRF_HEADER_NAME</li> </ul> </li> <li>JSON options<ul> <li>JWT_JSON_KEY</li> <li>JWT_REFRESH_JSON_KEY</li> </ul> </li> <li>Query options<ul> <li>JWT_QUERY_STRING_NAME</li> </ul> </li> </ul>"},{"location":"config/#main-options","title":"Main options","text":""},{"location":"config/#jwt_access_token_expires","title":"JWT_ACCESS_TOKEN_EXPIRES","text":"<p><code>datetime.timedelta(minutes=15)</code></p> <p>Validity period for access tokens expressed as <code>datetime.timedelta</code>. If configured with an environment variable, describe the expiration time in seconds.</p>"},{"location":"config/#jwt_algorithm","title":"JWT_ALGORITHM","text":"<p><code>\"HS256\"</code></p> <p>Signing algorithm for JWTs</p>"},{"location":"config/#jwt_decode_audience","title":"JWT_DECODE_AUDIENCE","text":"<p><code>None</code></p> <p>Audience claim or list of audience claims (aud) expected when decoding JWT</p>"},{"location":"config/#jwt_decode_issuer","title":"JWT_DECODE_ISSUER","text":"<p><code>None</code></p> <p>Issuer claim (iss) expected when decoding JWT</p>"},{"location":"config/#jwt_encode_audience","title":"JWT_ENCODE_AUDIENCE","text":"<p><code>None</code></p> <p>Audience claim or list of audience claims (aud) used to create JWT</p>"},{"location":"config/#jwt_encode_issuer","title":"JWT_ENCODE_ISSUER","text":"<p><code>None</code></p> <p>Issuer claim (iss) used to create JWT</p>"},{"location":"config/#jwt_private_key","title":"JWT_PRIVATE_KEY","text":"<p><code>None</code></p> <p>The secret key to encode JWT. This configuration must be set if <code>JWT_ALGORITHM</code> refers to an asymmetric algorithm.</p>"},{"location":"config/#jwt_public_key","title":"JWT_PUBLIC_KEY","text":"<p><code>None</code></p> <p>The secret key to decode JWT. This configuration must be set if <code>JWT_ALGORITHM</code> refers to an asymmetric algorithm.</p>"},{"location":"config/#jwt_refresh_token_expires","title":"JWT_REFRESH_TOKEN_EXPIRES","text":"<p><code>datetime.timedelta(days=20)</code></p> <p>Validity period for refresh tokens expressed as <code>datetime.timedelta</code>. If configured with an environment variable, describe the expiration time in seconds.</p>"},{"location":"config/#jwt_secret_key","title":"JWT_SECRET_KEY","text":"<p><code>None</code></p> <p>The secret key to encode/decode JWT. This configuration must be set if <code>JWT_ALGORITHM</code> refers to a symmetric algorithm.</p>"},{"location":"config/#jwt_token_location","title":"JWT_TOKEN_LOCATION","text":"<p><code>[\"headers\"]</code></p> <p>List of <code>TokenLocation</code> to configure FastJWT where to look JWT in requests. Avaialble options are: <code>headers</code>, <code>cookies</code>, <code>query</code>, <code>json</code></p>"},{"location":"config/#header-options","title":"Header options","text":"<p>These parameters are only relevant if <code>headers</code> is in <code>JWT_TOKEN_LOCATIONS</code></p>"},{"location":"config/#jwt_header_name","title":"JWT_HEADER_NAME","text":"<p><code>\"Authorization\"</code></p> <p>The header name containing the JWT in request.</p>"},{"location":"config/#jwt_header_type","title":"JWT_HEADER_TYPE","text":"<p><code>\"Bearer\"</code></p> <p>The header type containing the JWT in request. This parameters acts as a prefix before the token. If null, the header should only be composed of the JWT.</p>"},{"location":"config/#cookie-options","title":"Cookie options","text":"<p>These parameters are only relevant if <code>cookies</code> is in <code>JWT_TOKEN_LOCATIONS</code></p>"},{"location":"config/#jwt_access_cookie_name","title":"JWT_ACCESS_COOKIE_NAME","text":"<p><code>\"access_token_cookie\"</code></p> <p>Name of the cookie containing the access token</p>"},{"location":"config/#jwt_access_cookie_path","title":"JWT_ACCESS_COOKIE_PATH","text":"<p><code>\"/\"</code></p> <p>Path for the access cookie</p>"},{"location":"config/#jwt_cookie_csrf_protect","title":"JWT_COOKIE_CSRF_PROTECT","text":"<p><code>True</code></p> <p>Enables CSRF protection when using cookies.</p> <p>THIS SHOULD ALWAYS BE SET TO <code>True</code> IN PRODUCTION</p>"},{"location":"config/#jwt_cookie_domain","title":"JWT_COOKIE_DOMAIN","text":"<p><code>None</code></p> <p>Domain for cross domain cookies</p>"},{"location":"config/#jwt_cookie_max_age","title":"JWT_COOKIE_MAX_AGE","text":"<p><code>None</code></p> <p>WIP</p>"},{"location":"config/#jwt_cookie_samesite","title":"JWT_COOKIE_SAMESITE","text":"<p><code>\"Lax\"</code></p> <p>Cookie property for managing cross-site browsing. Available options are: <code>None</code>, <code>Lax</code>, <code>Strict</code></p>"},{"location":"config/#jwt_cookie_secure","title":"JWT_COOKIE_SECURE","text":"<p><code>True</code></p> <p>Enable the <code>Secure</code> property while setting cookies. Secured cookies can only be exchanged via HTTPS connection.</p> <p>THIS SHOULD ALWAYS BE SET TO <code>True</code> IN PRODUCTION</p> <p>While developing, you might set this option to <code>False</code> to test your application on localhost</p>"},{"location":"config/#jwt_refresh_cookie_name","title":"JWT_REFRESH_COOKIE_NAME","text":"<p><code>\"refresh_token_cookie\"</code></p> <p>Name of the cookie containing the refresh token</p>"},{"location":"config/#jwt_refresh_cookie_path","title":"JWT_REFRESH_COOKIE_PATH","text":"<p><code>\"/\"</code></p> <p>Path for the refresh cookie</p>"},{"location":"config/#csrf-options","title":"CSRF options","text":"<p>These parameters are only relevant if <code>cookies</code> is in <code>JWT_TOKEN_LOCATIONS</code> and <code>JWT_COOKIE_CSRF_PROTECT</code> is <code>True</code></p>"},{"location":"config/#jwt_access_csrf_cookie_name","title":"JWT_ACCESS_CSRF_COOKIE_NAME","text":"<p><code>\"csrf_access_token\"</code></p> <p>Name of the cookie containing the CSRF token.</p>"},{"location":"config/#jwt_access_csrf_cookie_path","title":"JWT_ACCESS_CSRF_COOKIE_PATH","text":"<p><code>\"/\"</code></p> <p>Path for the CSRF cookie</p>"},{"location":"config/#jwt_access_csrf_field_name","title":"JWT_ACCESS_CSRF_FIELD_NAME","text":"<p><code>\"csrf_token\"</code></p> <p>Form field name containing the CSRF token</p>"},{"location":"config/#jwt_access_csrf_header_name","title":"JWT_ACCESS_CSRF_HEADER_NAME","text":"<p><code>\"X-CSRF-TOKEN\"</code></p> <p>Name of the header containing the CSRF token</p>"},{"location":"config/#jwt_csrf_check_form","title":"JWT_CSRF_CHECK_FORM","text":"<p><code>False</code></p> <p>WIP</p>"},{"location":"config/#jwt_csrf_in_cookies","title":"JWT_CSRF_IN_COOKIES","text":"<p><code>True</code></p> <p>When enabled, store CSRF token in additional cookie</p>"},{"location":"config/#jwt_csrf_methods","title":"JWT_CSRF_METHODS","text":"<p><code>[\"POST\", \"PUT\", \"PATCH\", \"DELETE\"]</code></p> <p>Request methods for which CSRF checks should be performed</p>"},{"location":"config/#jwt_refresh_csrf_cookie_name","title":"JWT_REFRESH_CSRF_COOKIE_NAME","text":"<p><code>\"csrf_refresh_token\"</code></p> <p>Name of the cookie containing the CSRF token.</p>"},{"location":"config/#jwt_refresh_csrf_cookie_path","title":"JWT_REFRESH_CSRF_COOKIE_PATH","text":"<p><code>\"/\"</code></p> <p>Path for the CSRF cookie</p>"},{"location":"config/#jwt_refresh_csrf_field_name","title":"JWT_REFRESH_CSRF_FIELD_NAME","text":"<p><code>\"csrf_token\"</code></p> <p>Form field name containing the CSRF token</p>"},{"location":"config/#jwt_refresh_csrf_header_name","title":"JWT_REFRESH_CSRF_HEADER_NAME","text":"<p><code>\"X-CSRF-TOKEN\"</code></p> <p>Name of the header containing the CSRF token</p>"},{"location":"config/#json-options","title":"JSON options","text":""},{"location":"config/#jwt_json_key","title":"JWT_JSON_KEY","text":"<p><code>\"access_token\"</code></p> <p>Key containing the access token in the JSON body</p>"},{"location":"config/#jwt_refresh_json_key","title":"JWT_REFRESH_JSON_KEY","text":"<p><code>\"refresh_token\"</code></p> <p>Key containing the refresh token in the JSON body</p>"},{"location":"config/#query-options","title":"Query options","text":""},{"location":"config/#jwt_query_string_name","title":"JWT_QUERY_STRING_NAME","text":"<p><code>\"token\"</code></p> <p>Query parameter name containing the JWT</p>"},{"location":"deps/","title":"Dependencies","text":"<p>WIP</p> <p>This section is work in progress</p>"},{"location":"errors/","title":"Error Handling","text":"<p>FastJWT provides multiple exceptions to handle JWT specific errors</p>"},{"location":"errors/#fastjwt-exceptions","title":"FastJWT Exceptions","text":""},{"location":"errors/#fastjwtexception","title":"<code>FastJWTException</code>","text":"<p>PARENT: <code>Exception</code></p> <p>The Base FastJWT Exception. </p> <p>Note</p> <p>This exception is never raised directly in the code but is used to group all FastJWT exceptions under a same namespace.</p>"},{"location":"errors/#badconfigurationerror","title":"<code>BadConfigurationError</code>","text":"<p>PARENT: <code>FastJWTException</code></p> <p>Exception raised when FastJWT configuration contains wrong parameters. This exceptions might be raised when no secrets are sets, when a single secret is used with an asymmetric algorithm...</p>"},{"location":"errors/#jwtdecodeerror","title":"<code>JWTDecodeError</code>","text":"<p>PARENT: <code>FastJWTException</code></p> <p>Exception raised when decoding JSON Web Token fails. This exception is raised when the token is not a proper JWT or when a <code>jwt</code> claim validation is not met.  </p>"},{"location":"errors/#csrferror","title":"<code>CSRFError</code>","text":"<p>PARENT: <code>FastJWTException</code></p> <p>Exception raised when CSRF protection failed. This exception is raised when the CSRF validation has failed. Mostly due to failing double submit token comparison.</p>"},{"location":"errors/#tokenerror","title":"<code>TokenError</code>","text":"<p>PARENT: <code>FastJWTException</code></p> <p>Base Exception for token related errors. </p> <p>Note</p> <p>This exception is never raised directly in the code but is used to group all FastJWT token exceptions under a same namespace.</p>"},{"location":"errors/#missingtokenerror","title":"<code>MissingTokenError</code>","text":"<p>PARENT: <code>TokenError</code></p> <p>Exception raised when no token can be parsed from request. This exception is raised when a token is required and not available.</p>"},{"location":"errors/#missingcsrftokenerror","title":"<code>MissingCSRFTokenError</code>","text":"<p>PARENT: <code>MissingTokenError</code></p> <p>Exception raised when no CSRF token can be parsed from request. This exception is raised when a CSRF token is required and not available. Only raised with authentication via Cookies.</p>"},{"location":"errors/#revokedtokenerror","title":"<code>RevokedTokenError</code>","text":"<p>PARENT: <code>TokenError</code></p> <p>Exception raised when a revoked token has been used. This exception can only be raised if a revoked token callback has been set. See Custom Callbacks &gt; Token Revokation</p>"},{"location":"errors/#freshtokenrequirederror","title":"<code>FreshTokenRequiredError</code>","text":"<p>PARENT: <code>TokenError</code></p> <p>Exception raised when a not fresh token was used in request.</p>"},{"location":"errors/#tokentypeerror","title":"<code>TokenTypeError</code>","text":"<p>PARENT: <code>TokenError</code></p> <p>Exception raised when a specific token type is expected.</p> <p>Note</p> <p>This exception is never raised directly in the code but is used to group all FastJWT token type exceptions under a same namespace.</p>"},{"location":"errors/#accesstokenrequirederror","title":"<code>AccessTokenRequiredError</code>","text":"<p>PARENT: <code>TokenTypeError</code></p> <p>Exception raised when an <code>access</code> token is missing from request</p>"},{"location":"errors/#refreshtokenrequirederror","title":"<code>RefreshTokenRequiredError</code>","text":"<p>PARENT: <code>TokenTypeError</code></p> <p>Exception raised when an <code>refresh</code> token is missing from request</p>"},{"location":"errors/#automatic-error-handling","title":"Automatic Error Handling","text":"<p>FastJWT provides a simple way to handle these exceptions. By default, no exception is handled by FastJWT, and when raised, results in a <code>500 Internal Server Error</code> HTTP Code</p> <p><code>FastJWT.handle_errors</code> method provides automatic error handlers for a FastAPI application.</p> <pre><code>from fastapi import FastAPI, Depends\nfrom fastjwt import FastJWT\n\napp = FastAPI()\nsecurity = FastJWT()\n\nsecurity.handle_errors(app)\n\n@app.get('/protected', dependencies=[Depends(security.access_token_required)])\ndef protected():\n    return \"OK\"\n</code></pre> without Error Handlingwith Error Handling <pre><code>$ curl http://0.0.0.0:8000/protected\n500 Internal Server Error\n</code></pre> <pre><code>$ curl http://0.0.0.0:8000/protected\n401 {\"message\": \"Missing JWT in request\"}\n</code></pre> <p>All the predefined message are <code>FastJWT</code> properties and can be set as regular python properties. Here is a list of all the property names and default value.</p> <pre><code>MSG_DEFAULT = \"FastJWTException\"\nMSG_TOKEN_ERROR = \"Token Error\"\nMSG_MISSING_TOKEN_ERROR = \"Missing JWT in request\"\nMSG_MISSING_CSRF_ERROR = \"Missing CSRF double submit token in request\"\nMSG_TOKEN_TYPE_ERROR = \"Bad token type\"\nMSG_REVOKED_TOKEN_ERROR = \"Invalid token\"\nMSG_TOKEN_REQUIRED_ERROR = \"Token required\"\nMSG_FRESH_TOKEN_REQUIRED_ERROR = \"Fresh token required\"\nMSG_ACCESS_TOKEN_REQUIRED_ERROR = \"Access token required\"\nMSG_REFRESH_TOKEN_REQUIRED_ERROR = \"Refresh token required\"\nMSG_CSRF_ERROR = \"CSRF double submit does not match\"\nMSG_DECODE_JWT_ERROR = \"Invalid Token\"\n</code></pre>"},{"location":"errors/#custom-error-handling","title":"Custom Error Handling","text":"<p>If you need to enable a custom behavior on a specific error you can use the <code>FastAPI.exception_handler</code>. See FastAPI Handling Errors</p> <pre><code>from fastapi import FastAPI, Depends, Request\nfrom fastapi.responses import JSONResponse\nfrom fastjwt import FastJWT\nimport fastjwt.exceptions as fexc\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@app.exception_handler(fexc.MissingTokenError)\nasync def missing_token_exception_handler(\n    request: Request, \n    exc: fexc.MissingTokenError\n):\n    return JSONResponse(\n        status_code=401,\n        content={\"message\": \"Please provide an authentication token\"}\n    )\n\n@app.get('/protected', dependencies=[Depends(security.access_token_required)])\ndef protected():\n    return \"OK\"\n</code></pre>"},{"location":"fresh/","title":"Token Freshness","text":"<p>Token freshness mechanisms enable additional protection for sensitive operations.  Fresh tokens should only be generated when the user provides credentials information on a login operation.</p> <p>Every time a user authenticates itself with credentials, it receives a <code>fresh</code> token. Every time, an access token is refreshed (implicitly or explictly) the access token generated SHOULD NOT be <code>fresh</code>.</p> <p>Most of  your protected endpoints should not consider the <code>fresh</code> state of the access token, but in specific application cases, the use of a <code>fresh</code> token enables an additional layer of protection by requiring the user to authenticate itself.</p> <p>Such operations includes but are not limited to:</p> <ul> <li>Password update</li> <li>User information update</li> <li>Privilege/Permission management</li> <li>...</li> </ul>"},{"location":"fresh/#combined-with-explicit-refresh-mechanism","title":"Combined with explicit refresh mechanism","text":"<p>Let's start from the example in the previous Refreshing tokens section.</p> <pre><code>from pydantic import BaseModel\nfrom fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastapi import HTTPException\nfrom fastjwt import FastJWT\nfrom fastjwt import TokenPayload\n\napp = FastAPI()\nsecurity = FastJWT()\n\nclass LoginForm(BaseModel):\n    username: str\n    password: str\n\n@app.post('/login')\ndef login(data: LoginForm):\n    if data.username == \"test\" and data.password == \"test\":\n        access_token = security.create_access_token(\n            data.username, \n            fresh=True\n        )\n        refresh_token = security.create_refresh_token(data.username)\n        return {\n            \"access_token\": access_token, \n            \"refresh_token\": refresh_token\n        }\n    raise HTTPException(401, \"Bad username/password\")\n\n\n# We use the FastJWT.refresh_token_required method to enforce\n# the refresh token validation.\n@app.post('/refresh')\ndef refresh(\n    refresh_payload: TokenPayload = Depends(security.refresh_token_required)\n):\n    access_token = security.create_access_token(\n        refresh_payload.sub, \n        fresh=False\n    )\n    return {\"access_token\": access_token}\n\n\n@app.get('/protected', dependencies=[Depends(security.access_token_required)])\ndef protected():\n    return \"You have access to this protected resource\"\n\n@app.get('/sensitive_operation', dependencies=[Depends(security.fresh_token_required)])\ndef sensitive_operation():\n    return \"You have access to this sensitive operation\"\n</code></pre>"},{"location":"fresh/#create-fresh-access-tokens","title":"Create fresh access tokens","text":"<p>To create a <code>fresh</code> access token, use <code>fresh=True</code> argument in <code>FastJWT.create_access_token</code> method. </p> <p>On the <code>/login</code> route, we set the <code>fresh</code> argument to <code>True</code> because the token is generated after the user explicitly provided username/password combo.</p> <pre><code>@app.post('/login')\ndef login(data: LoginForm):\n    if data.username == \"test\" and data.password == \"test\":\n        access_token = security.create_access_token(\n            data.username, \n            fresh=True\n        )\n        refresh_token = security.create_refresh_token(data.username)\n        return {\n            \"access_token\": access_token, \n            \"refresh_token\": refresh_token\n        }\n    raise HTTPException(401, \"Bad username/password\")\n</code></pre> <p>Note</p> <p><code>FastJWT.create_access_token</code> has by default <code>fresh=False</code> to avoid implicit fresh token generation</p>"},{"location":"fresh/#refreshing-tokens","title":"Refreshing tokens","text":"<p>When refreshing tokens, you should always generate NOT <code>fresh</code> tokens. On the example below the <code>fresh</code> argument is set to <code>Fasle</code> explicitly,  the default behavior for the <code>FastJWT.create_access_token</code> is to generate a NON <code>fresh</code> token.</p> <pre><code>@app.post('/refresh')\ndef refresh(\n    refresh_payload: TokenPayload = Depends(security.refresh_token_required)\n):\n    access_token = security.create_access_token(\n        refresh_payload.sub, \n        fresh=False\n    )\n    return {\"access_token\": access_token}\n</code></pre>"},{"location":"fresh/#requiring-fresh-tokens","title":"Requiring fresh tokens","text":"<p>The first <code>/protected</code> route acts as usual, regardless of the <code>fresh</code> token's state.</p> <p>At the opposite, the <code>/sensitive_operation</code> route will now require a fresh token to be executed. This behavior is defined by the <code>FastJWT.fresh_token_required</code> dependency</p> <pre><code>@app.get('/protected', dependencies=[Depends(security.access_token_required)])\ndef protected():\n    return \"You have access to this protected resource\"\n\n@app.get('/sensitive_operation', dependencies=[Depends(security.fresh_token_required)])\ndef sensitive_operation():\n    return \"You have access to this sensitive operation\"\n</code></pre> 1. Login2. Sensitive Operation3. Refresh access token4. Sensitive operation <pre><code># We login to obtain a fresh token\n$ curl -s -X POST --json '{\"username\":\"test\", \"password\":\"test\"}' http://0.0.0.0:8000/login\n{\"access_token\": $FRESH_TOKEN, \"refresh_token\": $REFRESH_TOKEN}\n</code></pre> <pre><code># We request the sensitive operation with the fresh token\n$ curl -s --oauth2-bearer $FRESH_TOKEN http://0.0.0.0:8000/sensitive_operation\n\"You have access to this sensitive operation\"\n</code></pre> <pre><code># We refresh the access token to get a new non fresh one\n$ curl -s --oauth2-bearer $REFRESH_TOKEN http://0.0.0.0:8000/refresh\n{\"access_token\": $NON_FRESH_TOKEN}\n</code></pre> <pre><code># We request the sensitive operation with the non fresh token\n$ curl -s --oauth2-bearer $FRESH_TOKEN http://0.0.0.0:8000/sensitive_operation\nInteral server error\n</code></pre> Note on Internal server error <p>As you might notice, the step 4 results in an 500 HTTP Internal Server Error. This is the expected behavior, since error handling is by default disabled on FastJWT and should be enabled or handled by you to avoid errors</p>"},{"location":"locations/","title":"JWT Locations","text":"<p>JWT can be provided with request in different locations. FastJWT allows to control and configure the JWT locations via the <code>JWT_TOKEN_LOCATION</code> setting.</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\nfrom fastjwt import FJWTConfig\n\napp = FastAPI()\n\nconfig = FJWTConfig()\nconfig.JWT_TOKEN_LOCATION = [\"headers\", \"query\", \"cookies\", \"json\"]\n\nsecurity = FastJWT(config=config)\n\n@app.get('/protected', dependencies=[Depends(security.access_token_required)])\ndef protected():\n    return \"OK\"\n</code></pre>"},{"location":"locations/#headers","title":"Headers","text":"<p>JWT via headers is controlled by two settings:</p> <ul> <li><code>JWT_HEADER_NAME</code>: The header name. By default <code>'Authorization'</code></li> <li><code>JWT_HEADER_TYPE</code>: The header value type/prefix. By default <code>'Bearer'</code></li> </ul> <p>The FastJWT instance will check this specific header whenever it needs to retrieve a token if the <code>\"headers\"</code> location is in <code>JWT_TOKEN_LOCATION</code></p> <p>Authentication is only based on the presence of the <code>JWT_HEADER_NAME</code> header in the headers. To log out your user, remove the authorization header.</p> curlJavaScriptPython <pre><code>$ curl --oauth2-bearer $TOKEN http://0.0.0.0:8000/protected\n \"OK\"\n# OR\n$ curl -H 'Authorization: \"Bearer $TOKEN\"' http://0.0.0.0:8000/protected\n</code></pre> <pre><code>async function requestProtectedRoute(TOKEN){\n    const response = await fetch(\"http://0.0.0.0:8000/protected\", {\n        method: \"GET\",\n        headers: {\n            \"Authorization\": `Bearer ${TOKEN}`\n        }\n    })\n    return response\n}\n</code></pre> <pre><code>import requests\n\nr = request.get(\n    \"http://0.0.0.0:8000/protected\", \n    headers={\n        \"Authorization\": f\"Bearer {TOKEN}\"\n    }\n)\n</code></pre>"},{"location":"locations/#query-parameters","title":"Query Parameters","text":"<p>JWT via query parameters is controlled by a single setting:</p> <ul> <li><code>JWT_QUERY_STRING_NAME</code>: The key used in the query string to identify the token. By default <code>'token'</code></li> </ul> <p>Warning</p> <p>It is important to remember that using JWT in query strings is NOT advised. Even with HTTPS protocol, the request URL is not protected, hence the token is visible. Such request will be saved in plain text in browsers and could be easily compromised.</p> <p>Specific cases may be of use, for example in case of one time tokens for email validation...</p> <p>To use JWT in query strings you just need to suffix your URL with <code>?token=$TOKEN</code></p> curlJavaScriptPython <pre><code>$ curl http://0.0.0.0:8000/protected?token=$TOKEN\n \"OK\"\n</code></pre> <pre><code>async function requestProtectedRoute(TOKEN){\n    const response = await fetch(`http://0.0.0.0:8000/protected?token=${TOKEN}`)\n    return response\n}\n</code></pre> <pre><code>import requests\n\nr = request.get(f\"http://0.0.0.0:8000/protected?token={TOKEN}\")\n</code></pre>"},{"location":"locations/#json-body","title":"JSON Body","text":"<p>JWT via JSON Body is controlled by the following parameters:</p> <ul> <li><code>JWT_JSON_KEY</code>: The json key relative to the access token. By default <code>access_token</code></li> <li><code>JWT_REFRESH_JSON_KEY</code>: The json key relative to the refresh token. By default <code>refresh_token</code></li> </ul> <p>Please note that sending JWT via JSON Body cannot be accomplished with GET requests, and require the <code>Content-Type: application/json</code> header.</p> curlJavaScriptPython <pre><code>curl -X POST -s --json '{\"access_token\":\"$TOKEN\"}' http://0.0.0.0:8000/protected\n \"OK\"\n</code></pre> <pre><code>async function requestProtectedRoute(TOKEN){\n    const response = await fetch(\"http://0.0.0.0:8000/protected\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: {\n            \"access_token\": TOKEN\n        }\n    })\n    return response\n}\n</code></pre> <pre><code>import requests\n\nr = request.post(\n    \"http://0.0.0.0:8000/protected\", \n    data={\n        \"access_token\": TOKEN\n    }\n)\n</code></pre>"},{"location":"locations/#cookies","title":"Cookies","text":"<p>JWT via Cookies is controlled by the following parameters:</p> <ul> <li><code>JWT_ACCESS_COOKIE_NAME</code>: Cookie name containing the access token. By default <code>access_token_cookie</code></li> <li><code>JWT_ACCESS_COOKIE_PATH</code>: Path of the access token cookie. By default <code>/</code></li> <li><code>JWT_COOKIE_CSRF_PROTECT</code>: Enable CSRF protection for cookie authentication. By default <code>True</code></li> <li><code>JWT_COOKIE_DOMAIN</code>: The domain for cookies set by FastJWT. By default <code>None</code></li> <li><code>JWT_COOKIE_MAX_AGE</code>: Max age for cookies set by FastJWT. By default <code>None</code></li> <li><code>JWT_COOKIE_SAMESITE</code>: The SameSite property for cookies set by FastJWT. By default <code>Lax</code></li> <li><code>JWT_COOKIE_SECURE</code>: Enable Cookie Secure property. By default <code>True</code></li> <li><code>JWT_REFRESH_COOKIE_NAME</code>: Cookie name containing the refresh token. By default <code>refresh_token_cookie</code></li> <li><code>JWT_REFRESH_COOKIE_PATH</code>: Path of the refresh token cookie. By default <code>/</code></li> <li><code>JWT_ACCESS_CSRF_COOKIE_NAME</code>: Cookie name containing the access CSRF token. By default <code>csrf_access_token</code></li> <li><code>JWT_ACCESS_CSRF_COOKIE_PATH</code>: Path of the access CSRF token cookie. By default <code>/</code></li> <li><code>JWT_CSRF_IN_COOKIES</code>: Add CSRF tokens when cookies are set by FastJWT. By default <code>True</code></li> <li><code>JWT_REFRESH_CSRF_COOKIE_NAME</code>: Cookie name containing the refresh CSRF token. By default <code>csrf_refresh_cookie</code></li> <li><code>JWT_REFRESH_CSRF_COOKIE_PATH</code>: Path of the refresf CSRF token cookie. By default <code>/</code></li> </ul> <p>If you develop an API to be consumed by a front end application (on web browser). Cookies are an efficient way to provide authentication.</p> <p>Note on HTTP Only</p> <p><code>access</code> &amp; <code>refresh</code> tokens set in cookies are <code>HTTP Only</code>. Meaning they cannot be accessed by JavaScript on client side. This property of <code>[access|refresh]</code> token cookies is hard coded and is not configurable. This is the expected behavior for authentication through Cookies to avoid XSS (Cross Site Scripting) attacks.</p> <p>See Cross-site scripting (XSS)</p> <p>Note on Secure</p> <p><code>Secure</code> cookie property requires an HTTPS request to send the secure cookie. The <code>JWT_COOKIE_SECURE</code> parameter should always be <code>True</code> in production. It is set as a configurable parameter for ease of development.</p> <p>While JWTs in cookies are suitable for web application authentication, they require additional work to prevent attacks. One of the most common attack on cookies is Cross Site Request Forgery (CSRF).</p> <p>To prevent such CSRF attacks, FastJWT provides double submit CSRF token when setting cookies. The idea is to add a second layer of validation. The CSRF prevention workflow can be summarized as followed:</p> <ol> <li>Login<ul> <li>When you log in into your account, the server adds a <code>Set-Cookie</code> header for your <code>access</code> token.     This cookie is <code>Secure</code> and <code>HTTP Only</code>, meaning it cannot be read by JavaScript.      This token is the base64 encoded JWT signed with your secrets and contains a <code>csrf</code> claim with a UUID.</li> <li>Besides the access token, the server adds another <code>Set-Cookie</code> header for the CSRF token.     This CSRF cookie does not have the <code>HTTP Only</code> property and can be read by client-side JavaScript.</li> </ul> </li> <li>Client-Side request<ul> <li>When a request is made by the client-side, the request headers should include the CSRF double dubmit token.     If not, the server will invalidate the request and produce a <code>CSRFError</code>.     If the CSRF token provided does not match the JWT <code>csrf</code> claim, the server will invalidate the request.</li> </ul> </li> </ol> <p>This workflow prevents CSRF attacks because you need to pass explicitly the CSRF token in your request headers (which is not a default behavior) and JavaScript from another domain will not have read access to this CSRF cookie.</p> curlJavaScriptPython <pre><code>curl -X POST -s --cookie \"access_token_cookie=$TOKEN\" -H 'X-CSRF-TOKEN: \"$CSRF_TOKEN\"' http://0.0.0.0:8000/protected\n\"OK\"\n</code></pre> <pre><code>function getCookie(cname) {\n    let name = cname + \"=\";\n    let ca = document.cookie.split(';');\n    for(let i = 0; i &lt; ca.length; i++) {\n        let c = ca[i];\n    while (c.charAt(0) == ' ') {\n        c = c.substring(1);\n    }\n    if (c.indexOf(name) == 0) {\n        return c.substring(name.length, c.length);\n    }\n    }\n    return \"\";\n}\n\nfunction getCSRFCookie() {\n    return getCookie(\"csrf_access_token\")\n}\n\nasync function requestProtectedRoute(){\n    const response = await fetch(\"http://0.0.0.0:8000/protected\", {\n        method: \"POST\",\n        credentials: 'include'\n        headers: {\n            \"X-CSRF-TOKEN\": getCSRFCookie()\n        },\n    })\n    return response\n}\n</code></pre> <pre><code>import requests\n\nr = request.post(\n    \"http://0.0.0.0:8000/protected\", \n    headers= {\n        \"X-CSRF-TOKEN\": CSRF_TOKEN\n    },\n    cookies={\n        \"access_token_cookie\": TOKEN,\n    }\n)\n</code></pre>"},{"location":"refresh/","title":"Refreshing Tokens","text":"<p>Since JWTs have a strict <code>exp</code> Expiration Time, a long session might result in multiple logouts and <code>401 Authentication</code> errors. To avoid such bahvior, refresh tokens are used to enable the generation of additional access token without the need to log in again.</p>"},{"location":"refresh/#implicit-refresh-with-cookies","title":"Implicit refresh with Cookies","text":"<p>WIP</p> <p>This section is work in progress</p>"},{"location":"refresh/#explicit-refresh","title":"Explicit refresh","text":"<p>When your application cannot use implicit refresh because cookies are not an option (mobile application, SDKs, APIs,...), you might need to declare explicitly the refresh logic on you application.</p> <pre><code>from pydantic import BaseModel\nfrom fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastapi import HTTPException\nfrom fastjwt import FastJWT\nfrom fastjwt import TokenPayload\n\napp = FastAPI()\nsecurity = FastJWT()\n\nclass LoginForm(BaseModel):\n    username: str\n    password: str\n\n@app.post('/login')\ndef login(data: LoginForm):\n    if data.username == \"test\" and data.password == \"test\":\n        access_token = security.create_access_token(data.username)\n        refresh_token = security.create_refresh_token(data.username)\n        return {\n            \"access_token\": access_token, \n            \"refresh_token\": refresh_token\n        }\n    raise HTTPException(401, \"Bad username/password\")\n\n\n# We use the FastJWT.refresh_token_required method to enforce\n# the refresh token validation.\n@app.post('/refresh')\ndef refresh(\n    refresh_payload: TokenPayload = Depends(security.refresh_token_required)\n):\n    access_token = security.create_access_token(refresh_payload.sub)\n    return {\"access_token\": access_token}\n\n\n@app.get('/protected', dependencies=[Depends(security.access_token_required)])\ndef protected():\n    return \"You have access to this protected resource\"\n</code></pre> <p>On this example, the <code>/refresh</code> route will only look for a valid refresh token in request. Once verified, it generates a new access token to be used to extend the session. </p> <p>This example is a very basic implementation of an explicit refresh mechanism. On a production case you might want to retrieve the current access token to revoke it. Hence avoiding to generate infinite valid access token.</p> 1. Login2. Sensitive Operation3. Refresh access token <pre><code># We login to obtain a token\n$ curl -s -X POST --json '{\"username\":\"test\", \"password\":\"test\"}' http://0.0.0.0:8000/login\n{\"access_token\": $TOKEN, \"refresh_token\": $REFRESH_TOKEN}\n</code></pre> <pre><code># We request the protceted route with the token\n$ curl -s --oauth2-bearer $TOKEN http://0.0.0.0:8000/sensitive_operation\n\"You have access to this sensitive operation\"\n</code></pre> <pre><code># We refresh the access token to get a new one\n$ curl -s --oauth2-bearer $REFRESH_TOKEN http://0.0.0.0:8000/refresh\n{\"access_token\": $NEW_TOKEN}\n</code></pre> <p>As you can see on the last step, refreshing mechanism allow to obtain new tokens without the need to authenticate again.</p>"},{"location":"api/config/","title":"FJWTConfig","text":"<p>             Bases: <code>BaseSettings</code></p> <p>FastJWT Base Configuration Object</p> Source code in <code>fastjwt/config.py</code> <pre><code>class FJWTConfig(BaseSettings):\n    \"\"\"FastJWT Base Configuration Object\"\"\"\n\n    # General Options\n    JWT_ACCESS_TOKEN_EXPIRES: Optional[timedelta] = timedelta(minutes=15)\n    JWT_ALGORITHM: AlgorithmType = \"HS256\"\n    JWT_DECODE_ALGORITHMS: Sequence[AlgorithmType] = Field(\n        default_factory=lambda: [\"HS256\"]\n    )\n    JWT_DECODE_AUDIENCE: Optional[StrOrSeq] = None\n    JWT_DECODE_ISSUER: Optional[str] = None\n    JWT_DECODE_LEEWAY: Optional[int] = 0\n    JWT_ENCODE_AUDIENCE: Optional[StrOrSeq] = None\n    JWT_ENCODE_ISSUER: Optional[str] = None\n    JWT_ENCODE_NBF: bool = True\n    JWT_ERROR_MESSAGE_KEY: str = \"msg\"\n    JWT_IDENTITY_CLAIM: str = \"sub\"\n    JWT_PRIVATE_KEY: Optional[str] = None\n    JWT_PUBLIC_KEY: Optional[str] = None\n    JWT_REFRESH_TOKEN_EXPIRES: Optional[timedelta] = timedelta(days=20)\n    JWT_SECRET_KEY: Optional[str] = None\n    JWT_TOKEN_LOCATION: TokenLocations = Field([\"headers\"])\n    # Header Options\n    JWT_HEADER_NAME: str = \"Authorization\"\n    JWT_HEADER_TYPE: str = \"Bearer\"\n    # Cookies Options\n    JWT_ACCESS_COOKIE_NAME: str = \"access_token_cookie\"\n    JWT_ACCESS_COOKIE_PATH: str = \"/\"\n    JWT_COOKIE_CSRF_PROTECT: bool = True\n    JWT_COOKIE_DOMAIN: Optional[str] = None\n    JWT_COOKIE_MAX_AGE: Optional[int] = None\n    JWT_COOKIE_SAMESITE: SameSitePolicy = \"Lax\"\n    JWT_COOKIE_SECURE: bool = True\n    JWT_REFRESH_COOKIE_NAME: str = \"refresh_token_cookie\"\n    JWT_REFRESH_COOKIE_PATH: str = \"/\"\n    JWT_SESSION_COOKIE: bool = True\n    # CSRF Options\n    JWT_ACCESS_CSRF_COOKIE_NAME: str = \"csrf_access_token\"\n    JWT_ACCESS_CSRF_COOKIE_PATH: str = \"/\"\n    JWT_ACCESS_CSRF_FIELD_NAME: str = \"csrf_token\"\n    JWT_ACCESS_CSRF_HEADER_NAME: str = \"X-CSRF-TOKEN\"\n    JWT_CSRF_CHECK_FORM: bool = False\n    JWT_CSRF_IN_COOKIES: bool = True\n    JWT_CSRF_METHODS: HTTPMethods = Field(\n        default_factory=lambda: [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n    )\n    JWT_REFRESH_CSRF_COOKIE_NAME: str = \"csrf_refresh_token\"\n    JWT_REFRESH_CSRF_COOKIE_PATH: str = \"/\"\n    JWT_REFRESH_CSRF_FIELD_NAME: str = \"csrf_token\"\n    JWT_REFRESH_CSRF_HEADER_NAME: str = \"X-CSRF-TOKEN\"\n    # Query Options\n    JWT_QUERY_STRING_NAME: str = \"token\"\n    # JSON Option\n    JWT_JSON_KEY: str = \"access_token\"\n    JWT_REFRESH_JSON_KEY: str = \"refresh_token\"\n\n    # Implicit Refresh Options\n    JWT_IMPLICIT_REFRESH_ROUTE_EXCLUDE: List[str] = Field(default_factory=list)\n    JWT_IMPLICIT_REFRESH_ROUTE_INCLUDE: List[str] = Field(default_factory=list)\n    JWT_IMPLICIT_REFRESH_METHOD_EXCLUDE: HTTPMethods = Field(default_factory=list)\n    JWT_IMPLICIT_REFRESH_METHOD_INCLUDE: HTTPMethods = Field(default_factory=list)\n    JWT_IMPLICIT_REFRESH_DELTATIME: timedelta = timedelta(minutes=10)\n\n    @property\n    def is_algo_symmetric(self) -&gt; bool:\n        \"\"\"Check if the JWT_ALGORITHM is a symmetric encryption algorithm\n\n        Returns:\n            bool: Whether or not the algorithm is symmetric\n        \"\"\"\n        return (\n            self.JWT_ALGORITHM in get_default_algorithms()\n            and self.JWT_ALGORITHM not in requires_cryptography\n        )\n\n    @property\n    def is_algo_asymmetric(self) -&gt; bool:\n        \"\"\"Check if the JWT_ALGORITHM is an asymmetric encryption algorithm\n\n        Returns:\n            bool: Whether or not the algorithm is asymmetric\n        \"\"\"\n        return (\n            self.JWT_ALGORITHM in get_default_algorithms()\n            and self.JWT_ALGORITHM in requires_cryptography\n        )\n\n    def _get_key(self, crypto_value: str) -&gt; str:\n        if self.is_algo_symmetric:\n            key = self.JWT_SECRET_KEY\n        elif self.is_algo_asymmetric:\n            key = crypto_value\n        else:\n            raise BadConfigurationError(\n                f\"Bad Algorithm. Value allowed are '{get_default_algorithms()}'\"\n            )\n\n        if key is None:\n            raise BadConfigurationError(\n                \"SECRET is None.\",\n                \"Be sure to check the algorithm and to set JWT_SECRET_KEY | JWT_PUBLIC_KEY | JWT_PRIVATE_KEY accordingly\",\n            )\n        return key\n\n    def has_location(self, location: str) -&gt; bool:\n        \"\"\"Check if a given token location is allowed by the configuration\n\n        Args:\n            location (str): Token location\n\n        Returns:\n            bool: Whether or not the location is contained in JWT_TOKEN_LOCATION\n        \"\"\"\n        return location in self.JWT_TOKEN_LOCATION\n\n    @property\n    def PRIVATE_KEY(self) -&gt; str:\n        \"\"\"Private key to encode token\n\n        Returns:\n            str: Private key\n        \"\"\"\n        return self._get_key(self.JWT_PRIVATE_KEY)\n\n    @property\n    def PUBLIC_KEY(self) -&gt; str:\n        \"\"\"Public key to decode token\n\n        Returns:\n            str: Public key\n        \"\"\"\n        return self._get_key(self.JWT_PUBLIC_KEY)\n</code></pre>"},{"location":"api/config/#fastjwt.config.FJWTConfig.PRIVATE_KEY","title":"<code>PRIVATE_KEY: str</code>  <code>property</code>","text":"<p>Private key to encode token</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Private key</p>"},{"location":"api/config/#fastjwt.config.FJWTConfig.PUBLIC_KEY","title":"<code>PUBLIC_KEY: str</code>  <code>property</code>","text":"<p>Public key to decode token</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Public key</p>"},{"location":"api/config/#fastjwt.config.FJWTConfig.is_algo_asymmetric","title":"<code>is_algo_asymmetric: bool</code>  <code>property</code>","text":"<p>Check if the JWT_ALGORITHM is an asymmetric encryption algorithm</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether or not the algorithm is asymmetric</p>"},{"location":"api/config/#fastjwt.config.FJWTConfig.is_algo_symmetric","title":"<code>is_algo_symmetric: bool</code>  <code>property</code>","text":"<p>Check if the JWT_ALGORITHM is a symmetric encryption algorithm</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether or not the algorithm is symmetric</p>"},{"location":"api/config/#fastjwt.config.FJWTConfig.has_location","title":"<code>has_location(location)</code>","text":"<p>Check if a given token location is allowed by the configuration</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>Token location</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether or not the location is contained in JWT_TOKEN_LOCATION</p> Source code in <code>fastjwt/config.py</code> <pre><code>def has_location(self, location: str) -&gt; bool:\n    \"\"\"Check if a given token location is allowed by the configuration\n\n    Args:\n        location (str): Token location\n\n    Returns:\n        bool: Whether or not the location is contained in JWT_TOKEN_LOCATION\n    \"\"\"\n    return location in self.JWT_TOKEN_LOCATION\n</code></pre>"},{"location":"api/deps/","title":"FastJWTDeps","text":"<p>             Bases: <code>Generic[T]</code></p> <p>Bundle of FastJWT capabilities</p> Note <p>This class is used to access FastJWT's capabilities within the scope of a FastAPI Request. It is accessible via the <code>FastJWT.BUNDLE</code> instance's attribute OR <code>FastJWT.get_dependency</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>_from</code> <code>FastJWT[T]</code> <p>FastJWT instance</p> required <code>request</code> <code>Request</code> <p>FastAPI Request instance. Defaults to None.</p> <code>None</code> <code>response</code> <code>Response</code> <p>FastAPI Response instance. Defaults to None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>request</code> <code>Request</code> <p>FastAPI Request instance</p> <code>response</code> <code>Response</code> <p>FastAPI Response instance</p> <code>_security</code> <code>FastJWT[T]</code> <p>FastJWT instance</p> Source code in <code>fastjwt/dependencies.py</code> <pre><code>class FastJWTDeps(Generic[T]):\n    \"\"\"Bundle of FastJWT capabilities\n\n    Note:\n        This class is used to access FastJWT's capabilities within\n        the scope of a FastAPI Request. It is accessible via the\n        `FastJWT.BUNDLE` instance's attribute OR `FastJWT.get_dependency` method.\n\n    Args:\n        _from (FastJWT[T]): FastJWT instance\n        request (Request, optional): FastAPI Request instance. Defaults to None.\n        response (Response, optional): FastAPI Response instance. Defaults to None.\n\n    Attributes:\n        request (Request): FastAPI Request instance\n        response (Response): FastAPI Response instance\n        _security (FastJWT[T]): FastJWT instance\n    \"\"\"\n\n    def __init__(\n        self,\n        _from: \"FastJWT[T]\",\n        request: Request = None,\n        response: Response = None,\n    ) -&gt; None:\n        \"\"\"See help(FastJWTDeps) for more info\n\n        Args:\n            _from (FastJWT[T]): FastJWT instance\n            request (Request, optional): FastAPI Request instance. Defaults to None.\n            response (Response, optional): FastAPI Response instance. Defaults to None.\n        \"\"\"\n        self._response = response\n        self._request = request\n        self._security = _from\n\n    @property\n    def request(self) -&gt; Request:\n        \"\"\"The FastAPI Request instance\"\"\"\n        return self._request\n\n    @property\n    def response(self) -&gt; Response:\n        \"\"\"The FastAPI Response instance\"\"\"\n        return self._response\n\n    def create_access_token(\n        self,\n        uid: str,\n        fresh: bool = False,\n        headers: Optional[Dict[str, Any]] = None,\n        expiry: Optional[DateTimeExpression] = None,\n        data: Optional[Dict[str, Any]] = None,\n        audience: Optional[StrOrSeq] = None,\n        *args,\n        **kwargs\n    ) -&gt; str:\n        \"\"\"Create an access token\n\n        Args:\n            uid (str): Unique identifier to generate token for\n            fresh (bool, optional): Generate fresh token. Defaults to False.\n            headers (Dict[str, Any], optional): TODO. Defaults to None.\n            expiry (DateTimeExpression, optional): User defined expiry claim.\n                Defaults to None.\n            data (Dict[str, Any], optional): Additional data store in token.\n                Defaults to None.\n            audience (StrOrSeq, optional): Audience claim. Defaults to None.\n\n        Returns:\n            str: Access Token\n        \"\"\"\n        return self._security.create_access_token(\n            uid, fresh, headers, expiry, data, audience, *args, **kwargs\n        )\n\n    def create_refresh_token(\n        self,\n        uid: str,\n        headers: Optional[Dict[str, Any]] = None,\n        expiry: Optional[DateTimeExpression] = None,\n        data: Optional[Dict[str, Any]] = None,\n        audience: Optional[StrOrSeq] = None,\n        *args: Any,\n        **kwargs: Any\n    ) -&gt; str:\n        \"\"\"Generate a refresh token\n\n        Args:\n            uid (str): Unique identifier to generate token for\n            headers (Dict[str, Any], optional): TODO. Defaults to None.\n            expiry (DateTimeExpression, optional): User defined expiry claim.\n                Defaults to None.\n            data (Dict[str, Any], optional): Additional data store in token.\n                Defaults to None.\n            audience (StrOrSeq, optional): Audience claim.\n                Defaults to None.\n\n        Returns:\n            str: Refresh Token\n        \"\"\"\n        return self._security.create_refresh_token(\n            uid, headers, expiry, data, audience, *args, **kwargs\n        )\n\n    def set_access_cookies(\n        self, token, response: Optional[Response] = None, max_age: Optional[int] = None\n    ):\n        \"\"\"Add 'Set-Cookie' for access token in response header\n\n        Args:\n            token (str): Access token\n            response (Response, optional): Response to set cookie on.\n                Defaults to None\n            max_age (int, optional): Max Age cookie paramater.\n                Defaults to None\n\n        Note:\n            When `response` is not provided,\n            the `FastJWTDeps.response` attribute is used.\n        \"\"\"\n        self._security.set_access_cookies(\n            token=token, response=(response or self._response), max_age=max_age\n        )\n\n    def set_refresh_cookies(\n        self, token, response: Optional[Response] = None, max_age: Optional[int] = None\n    ):\n        \"\"\"Add 'Set-Cookie' for refresh token in response header\n\n        Args:\n            token (str): Refresh token\n            response (Response): Response to set cookie on.\n                Defaults to None\n            max_age (int, optional): Max Age cookie paramater.\n                Defaults to None\n\n        Note:\n            When `response` is not provided,\n            the `FastJWTDeps.response` attribute is used.\n        \"\"\"\n        self._security.set_refresh_cookies(\n            token=token, response=(response or self._response), max_age=max_age\n        )\n\n    def unset_access_cookies(self, response: Optional[Response] = None):\n        \"\"\"Remove 'Set-Cookie' for access token in response header\n\n        Args:\n            response (Response, optional): Response to remove cooke from.\n                Defaults to None\n\n        Note:\n            When `response` is not provided,\n            the `FastJWTDeps.response` attribute is used.\n        \"\"\"\n        self._security.unset_access_cookies(response=(response or self._response))\n\n    def unset_refresh_cookies(self, response: Optional[Response] = None):\n        \"\"\"Remove 'Set-Cookie' for refresh token in response header\n\n        Args:\n            response (Response, optional): Response to remove cooke from.\n                Defaults to None\n\n        Note:\n            When `response` is not provided,\n            the `FastJWTDeps.response` attribute is used.\n        \"\"\"\n        self._security.unset_access_cookies(response=(response or self._response))\n\n    def unset_cookies(self, response: Optional[Response] = None):\n        \"\"\"Remove 'Set-Cookie' for tokens from response headers\n\n        Args:\n            response (Response): Response to remove token cookies from.\n                Defaults to None\n\n        Note:\n            When `response` is not provided,\n            the `FastJWTDeps.response` attribute is used.\n        \"\"\"\n        self._security.unset_cookies(response=(response or self._response))\n\n    async def get_current_subject(self) -&gt; Optional[T]:\n        \"\"\"Get the current subject instance\n\n        Use the request's token to retrieve the subject instance.\n        Enforce a validation step to ensure the token is valid.\n\n        Returns:\n            Optional[T]: Subject instance\n\n        Note:\n            This method will always return `None` if\n            `FastJWT.set_subject_getter` has not been set first.\n        \"\"\"\n        return await self._security.get_current_subject(request=self._request)\n</code></pre>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.request","title":"<code>request: Request</code>  <code>property</code>","text":"<p>The FastAPI Request instance</p>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.response","title":"<code>response: Response</code>  <code>property</code>","text":"<p>The FastAPI Response instance</p>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.__init__","title":"<code>__init__(_from, request=None, response=None)</code>","text":"<p>See help(FastJWTDeps) for more info</p> <p>Parameters:</p> Name Type Description Default <code>_from</code> <code>FastJWT[T]</code> <p>FastJWT instance</p> required <code>request</code> <code>Request</code> <p>FastAPI Request instance. Defaults to None.</p> <code>None</code> <code>response</code> <code>Response</code> <p>FastAPI Response instance. Defaults to None.</p> <code>None</code> Source code in <code>fastjwt/dependencies.py</code> <pre><code>def __init__(\n    self,\n    _from: \"FastJWT[T]\",\n    request: Request = None,\n    response: Response = None,\n) -&gt; None:\n    \"\"\"See help(FastJWTDeps) for more info\n\n    Args:\n        _from (FastJWT[T]): FastJWT instance\n        request (Request, optional): FastAPI Request instance. Defaults to None.\n        response (Response, optional): FastAPI Response instance. Defaults to None.\n    \"\"\"\n    self._response = response\n    self._request = request\n    self._security = _from\n</code></pre>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.create_access_token","title":"<code>create_access_token(uid, fresh=False, headers=None, expiry=None, data=None, audience=None, *args, **kwargs)</code>","text":"<p>Create an access token</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>Unique identifier to generate token for</p> required <code>fresh</code> <code>bool</code> <p>Generate fresh token. Defaults to False.</p> <code>False</code> <code>headers</code> <code>Dict[str, Any]</code> <p>TODO. Defaults to None.</p> <code>None</code> <code>expiry</code> <code>DateTimeExpression</code> <p>User defined expiry claim. Defaults to None.</p> <code>None</code> <code>data</code> <code>Dict[str, Any]</code> <p>Additional data store in token. Defaults to None.</p> <code>None</code> <code>audience</code> <code>StrOrSeq</code> <p>Audience claim. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Access Token</p> Source code in <code>fastjwt/dependencies.py</code> <pre><code>def create_access_token(\n    self,\n    uid: str,\n    fresh: bool = False,\n    headers: Optional[Dict[str, Any]] = None,\n    expiry: Optional[DateTimeExpression] = None,\n    data: Optional[Dict[str, Any]] = None,\n    audience: Optional[StrOrSeq] = None,\n    *args,\n    **kwargs\n) -&gt; str:\n    \"\"\"Create an access token\n\n    Args:\n        uid (str): Unique identifier to generate token for\n        fresh (bool, optional): Generate fresh token. Defaults to False.\n        headers (Dict[str, Any], optional): TODO. Defaults to None.\n        expiry (DateTimeExpression, optional): User defined expiry claim.\n            Defaults to None.\n        data (Dict[str, Any], optional): Additional data store in token.\n            Defaults to None.\n        audience (StrOrSeq, optional): Audience claim. Defaults to None.\n\n    Returns:\n        str: Access Token\n    \"\"\"\n    return self._security.create_access_token(\n        uid, fresh, headers, expiry, data, audience, *args, **kwargs\n    )\n</code></pre>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.create_refresh_token","title":"<code>create_refresh_token(uid, headers=None, expiry=None, data=None, audience=None, *args, **kwargs)</code>","text":"<p>Generate a refresh token</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>Unique identifier to generate token for</p> required <code>headers</code> <code>Dict[str, Any]</code> <p>TODO. Defaults to None.</p> <code>None</code> <code>expiry</code> <code>DateTimeExpression</code> <p>User defined expiry claim. Defaults to None.</p> <code>None</code> <code>data</code> <code>Dict[str, Any]</code> <p>Additional data store in token. Defaults to None.</p> <code>None</code> <code>audience</code> <code>StrOrSeq</code> <p>Audience claim. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Refresh Token</p> Source code in <code>fastjwt/dependencies.py</code> <pre><code>def create_refresh_token(\n    self,\n    uid: str,\n    headers: Optional[Dict[str, Any]] = None,\n    expiry: Optional[DateTimeExpression] = None,\n    data: Optional[Dict[str, Any]] = None,\n    audience: Optional[StrOrSeq] = None,\n    *args: Any,\n    **kwargs: Any\n) -&gt; str:\n    \"\"\"Generate a refresh token\n\n    Args:\n        uid (str): Unique identifier to generate token for\n        headers (Dict[str, Any], optional): TODO. Defaults to None.\n        expiry (DateTimeExpression, optional): User defined expiry claim.\n            Defaults to None.\n        data (Dict[str, Any], optional): Additional data store in token.\n            Defaults to None.\n        audience (StrOrSeq, optional): Audience claim.\n            Defaults to None.\n\n    Returns:\n        str: Refresh Token\n    \"\"\"\n    return self._security.create_refresh_token(\n        uid, headers, expiry, data, audience, *args, **kwargs\n    )\n</code></pre>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.get_current_subject","title":"<code>get_current_subject()</code>  <code>async</code>","text":"<p>Get the current subject instance</p> <p>Use the request's token to retrieve the subject instance. Enforce a validation step to ensure the token is valid.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Optional[T]: Subject instance</p> Note <p>This method will always return <code>None</code> if <code>FastJWT.set_subject_getter</code> has not been set first.</p> Source code in <code>fastjwt/dependencies.py</code> <pre><code>async def get_current_subject(self) -&gt; Optional[T]:\n    \"\"\"Get the current subject instance\n\n    Use the request's token to retrieve the subject instance.\n    Enforce a validation step to ensure the token is valid.\n\n    Returns:\n        Optional[T]: Subject instance\n\n    Note:\n        This method will always return `None` if\n        `FastJWT.set_subject_getter` has not been set first.\n    \"\"\"\n    return await self._security.get_current_subject(request=self._request)\n</code></pre>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.set_access_cookies","title":"<code>set_access_cookies(token, response=None, max_age=None)</code>","text":"<p>Add 'Set-Cookie' for access token in response header</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>response</code> <code>Response</code> <p>Response to set cookie on. Defaults to None</p> <code>None</code> <code>max_age</code> <code>int</code> <p>Max Age cookie paramater. Defaults to None</p> <code>None</code> Note <p>When <code>response</code> is not provided, the <code>FastJWTDeps.response</code> attribute is used.</p> Source code in <code>fastjwt/dependencies.py</code> <pre><code>def set_access_cookies(\n    self, token, response: Optional[Response] = None, max_age: Optional[int] = None\n):\n    \"\"\"Add 'Set-Cookie' for access token in response header\n\n    Args:\n        token (str): Access token\n        response (Response, optional): Response to set cookie on.\n            Defaults to None\n        max_age (int, optional): Max Age cookie paramater.\n            Defaults to None\n\n    Note:\n        When `response` is not provided,\n        the `FastJWTDeps.response` attribute is used.\n    \"\"\"\n    self._security.set_access_cookies(\n        token=token, response=(response or self._response), max_age=max_age\n    )\n</code></pre>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.set_refresh_cookies","title":"<code>set_refresh_cookies(token, response=None, max_age=None)</code>","text":"<p>Add 'Set-Cookie' for refresh token in response header</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Refresh token</p> required <code>response</code> <code>Response</code> <p>Response to set cookie on. Defaults to None</p> <code>None</code> <code>max_age</code> <code>int</code> <p>Max Age cookie paramater. Defaults to None</p> <code>None</code> Note <p>When <code>response</code> is not provided, the <code>FastJWTDeps.response</code> attribute is used.</p> Source code in <code>fastjwt/dependencies.py</code> <pre><code>def set_refresh_cookies(\n    self, token, response: Optional[Response] = None, max_age: Optional[int] = None\n):\n    \"\"\"Add 'Set-Cookie' for refresh token in response header\n\n    Args:\n        token (str): Refresh token\n        response (Response): Response to set cookie on.\n            Defaults to None\n        max_age (int, optional): Max Age cookie paramater.\n            Defaults to None\n\n    Note:\n        When `response` is not provided,\n        the `FastJWTDeps.response` attribute is used.\n    \"\"\"\n    self._security.set_refresh_cookies(\n        token=token, response=(response or self._response), max_age=max_age\n    )\n</code></pre>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.unset_access_cookies","title":"<code>unset_access_cookies(response=None)</code>","text":"<p>Remove 'Set-Cookie' for access token in response header</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Response to remove cooke from. Defaults to None</p> <code>None</code> Note <p>When <code>response</code> is not provided, the <code>FastJWTDeps.response</code> attribute is used.</p> Source code in <code>fastjwt/dependencies.py</code> <pre><code>def unset_access_cookies(self, response: Optional[Response] = None):\n    \"\"\"Remove 'Set-Cookie' for access token in response header\n\n    Args:\n        response (Response, optional): Response to remove cooke from.\n            Defaults to None\n\n    Note:\n        When `response` is not provided,\n        the `FastJWTDeps.response` attribute is used.\n    \"\"\"\n    self._security.unset_access_cookies(response=(response or self._response))\n</code></pre>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.unset_cookies","title":"<code>unset_cookies(response=None)</code>","text":"<p>Remove 'Set-Cookie' for tokens from response headers</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Response to remove token cookies from. Defaults to None</p> <code>None</code> Note <p>When <code>response</code> is not provided, the <code>FastJWTDeps.response</code> attribute is used.</p> Source code in <code>fastjwt/dependencies.py</code> <pre><code>def unset_cookies(self, response: Optional[Response] = None):\n    \"\"\"Remove 'Set-Cookie' for tokens from response headers\n\n    Args:\n        response (Response): Response to remove token cookies from.\n            Defaults to None\n\n    Note:\n        When `response` is not provided,\n        the `FastJWTDeps.response` attribute is used.\n    \"\"\"\n    self._security.unset_cookies(response=(response or self._response))\n</code></pre>"},{"location":"api/deps/#fastjwt.dependencies.FastJWTDeps.unset_refresh_cookies","title":"<code>unset_refresh_cookies(response=None)</code>","text":"<p>Remove 'Set-Cookie' for refresh token in response header</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Response to remove cooke from. Defaults to None</p> <code>None</code> Note <p>When <code>response</code> is not provided, the <code>FastJWTDeps.response</code> attribute is used.</p> Source code in <code>fastjwt/dependencies.py</code> <pre><code>def unset_refresh_cookies(self, response: Optional[Response] = None):\n    \"\"\"Remove 'Set-Cookie' for refresh token in response header\n\n    Args:\n        response (Response, optional): Response to remove cooke from.\n            Defaults to None\n\n    Note:\n        When `response` is not provided,\n        the `FastJWTDeps.response` attribute is used.\n    \"\"\"\n    self._security.unset_access_cookies(response=(response or self._response))\n</code></pre>"},{"location":"api/exceptions/","title":"FastJWT Exception","text":""},{"location":"api/exceptions/#fastjwt.exceptions.AccessTokenRequiredError","title":"<code>AccessTokenRequiredError</code>","text":"<p>             Bases: <code>TokenTypeError</code></p> <p>Exception raised when an <code>access</code> token is missing from request</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class AccessTokenRequiredError(TokenTypeError):\n    \"\"\"Exception raised when an `access` token is missing from request\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.BadConfigurationError","title":"<code>BadConfigurationError</code>","text":"<p>             Bases: <code>FastJWTException</code></p> <p>Exception raised when FastJWT configuration contains wrong parameters</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class BadConfigurationError(FastJWTException):\n    \"\"\"Exception raised when FastJWT configuration contains wrong parameters\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.CSRFError","title":"<code>CSRFError</code>","text":"<p>             Bases: <code>FastJWTException</code></p> <p>Exception raised when CSRF protection failed</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class CSRFError(FastJWTException):\n    \"\"\"Exception raised when CSRF protection failed\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.FastJWTException","title":"<code>FastJWTException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base FastJWT Exception</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class FastJWTException(Exception):\n    \"\"\"Base FastJWT Exception\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.FreshTokenRequiredError","title":"<code>FreshTokenRequiredError</code>","text":"<p>             Bases: <code>TokenError</code></p> <p>Exception raised when a not fresh token was used in request</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class FreshTokenRequiredError(TokenError):\n    \"\"\"Exception raised when a not fresh token was used in request\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.JWTDecodeError","title":"<code>JWTDecodeError</code>","text":"<p>             Bases: <code>FastJWTException</code></p> <p>Exception raised when decoding JSON Web Token fails</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class JWTDecodeError(FastJWTException):\n    \"\"\"Exception raised when decoding JSON Web Token fails\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.MissingCSRFTokenError","title":"<code>MissingCSRFTokenError</code>","text":"<p>             Bases: <code>MissingTokenError</code></p> <p>Exception raised when no CSRF token can be parsed from request</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class MissingCSRFTokenError(MissingTokenError):\n    \"\"\"Exception raised when no CSRF token can be parsed from request\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.MissingTokenError","title":"<code>MissingTokenError</code>","text":"<p>             Bases: <code>TokenError</code></p> <p>Exception raised when no token can be parsed from request</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class MissingTokenError(TokenError):\n    \"\"\"Exception raised when no token can be parsed from request\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.NoAuthorizationError","title":"<code>NoAuthorizationError</code>","text":"<p>             Bases: <code>FastJWTException</code></p> <p>Exception raised when no token can be parsed from request</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class NoAuthorizationError(FastJWTException):\n    \"\"\"Exception raised when no token can be parsed from request\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.RefreshTokenRequiredError","title":"<code>RefreshTokenRequiredError</code>","text":"<p>             Bases: <code>TokenTypeError</code></p> <p>Exception raised when an <code>refresh</code> token is missing from request</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class RefreshTokenRequiredError(TokenTypeError):\n    \"\"\"Exception raised when an `refresh` token is missing from request\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.RevokedTokenError","title":"<code>RevokedTokenError</code>","text":"<p>             Bases: <code>TokenError</code></p> <p>Exception raised when a revoked token has been used</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class RevokedTokenError(TokenError):\n    \"\"\"Exception raised when a revoked token has been used\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.TokenError","title":"<code>TokenError</code>","text":"<p>             Bases: <code>FastJWTException</code></p> <p>Base Exception for token related errors</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class TokenError(FastJWTException):\n    \"\"\"Base Exception for token related errors\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.TokenRequiredError","title":"<code>TokenRequiredError</code>","text":"<p>             Bases: <code>TokenError</code></p> <p>Exception raised when no token was used in request</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class TokenRequiredError(TokenError):\n    \"\"\"Exception raised when no token was used in request\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#fastjwt.exceptions.TokenTypeError","title":"<code>TokenTypeError</code>","text":"<p>             Bases: <code>TokenError</code></p> <p>Exception raised when a specific token type is expected</p> Source code in <code>fastjwt/exceptions.py</code> <pre><code>class TokenTypeError(TokenError):\n    \"\"\"Exception raised when a specific token type is expected\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/fastjwt/","title":"FastJWT","text":"<p>             Bases: <code>_CallbackHandler[T]</code>, <code>_ErrorHandler</code></p> <p>The base FastJWT object</p> <p>FastJWT enables JWT management within a FastAPI application. Its main purpose is to provide a reusable &amp; simple syntax to protect API with JSON Web Token authentication.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>FJWTConfig</code> <p>Configuration instance to use. Defaults to FJWTConfig()</p> <code>FJWTConfig()</code> <code>model</code> <code>Optional[T]</code> <p>Model type hint. Defaults to Dict[str, Any]</p> <code>Dict[str, Any]</code> Note <p>FastJWT is a Generic python object. Its TypeVar is not mandatory but helps type hinting furing development</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>class FastJWT(_CallbackHandler[T], _ErrorHandler):\n    \"\"\"The base FastJWT object\n\n    FastJWT enables JWT management within a FastAPI application.\n    Its main purpose is to provide a reusable &amp; simple syntax to protect API\n    with JSON Web Token authentication.\n\n    Args:\n        config (FJWTConfig, optional): Configuration instance to use.\n            Defaults to FJWTConfig()\n        model (Optional[T], optional): Model type hint.\n            Defaults to Dict[str, Any]\n\n    Note:\n        FastJWT is a Generic python object.\n        Its TypeVar is not mandatory but helps type hinting furing development\n\n    \"\"\"\n\n    def __init__(\n        self, config: FJWTConfig = FJWTConfig(), model: Optional[T] = Dict[str, Any]\n    ) -&gt; None:\n        \"\"\"FastJWT base object\n\n        Args:\n            config (FJWTConfig, optional): Configuration instance to use.\n                Defaults to FJWTConfig()\n            model (Optional[T], optional): Model type hint.\n                Defaults to Dict[str, Any]\n        \"\"\"\n        super().__init__(model=model)\n        super(_CallbackHandler, self).__init__()\n        self._config = config\n\n    def load_config(self, config: FJWTConfig) -&gt; None:\n        \"\"\"Loads a FJWTConfig as the new configuration\n\n        Args:\n            config (FJWTConfig): Configuration to load\n        \"\"\"\n        self._config = config\n\n    @property\n    def config(self) -&gt; FJWTConfig:\n        \"\"\"FastJWT Configuration getter\n\n        Returns:\n            FJWTConfig: Configuration BaseSettings\n        \"\"\"\n        return self._config\n\n    # region Core methods\n\n    def _create_payload(\n        self,\n        uid: str,\n        type: str,\n        fresh: bool = False,\n        expiry: Optional[DateTimeExpression] = None,\n        data: Optional[Dict[str, Any]] = None,\n        audience: Optional[StrOrSeq] = None,\n        **kwargs\n    ) -&gt; TokenPayload:\n        \"\"\"Create a token payload\n\n        Args:\n            uid (str): Unique identifier to generate token for\n            type (str): Token type\n            fresh (bool, optional): Generate fresh token. Defaults to False.\n            expiry (Optional[DateTimeExpression], optional): User defined expiry claim.\n                Defaults to None.\n            data (Optional[Dict[str, Any]], optional): Additional data store in token.\n                Defaults to None.\n            audience (Optional[StrOrSeq], optional): Audience claim. Defaults to None.\n\n        Returns:\n            TokenPayload: Token Payload instance\n        \"\"\"\n        # Handle additional data\n        if data is None:\n            data = {}\n        # Handle expiry date\n        exp = expiry\n        if exp is None:\n            exp = (\n                self.config.JWT_ACCESS_TOKEN_EXPIRES\n                if type == \"access\"\n                else self.config.JWT_REFRESH_TOKEN_EXPIRES\n            )\n        # Handle CSRF\n        csrf = None\n        if self.config.has_location(\"cookies\") and self.config.JWT_COOKIE_CSRF_PROTECT:\n            csrf = get_uuid()\n        # Handle audience\n        aud = audience\n        if aud is None:\n            aud = self.config.JWT_ENCODE_AUDIENCE\n        payload = TokenPayload(\n            sub=uid,\n            fresh=fresh,\n            exp=exp,\n            type=type,\n            iss=self.config.JWT_ENCODE_ISSUER,\n            aud=aud,\n            csrf=csrf,\n            # Handle NBF\n            nbf=None,\n            **data\n        )\n        return payload\n\n    def _create_token(\n        self,\n        uid: str,\n        type: str,\n        fresh: bool = False,\n        headers: Optional[Dict[str, Any]] = None,\n        expiry: Optional[DateTimeExpression] = None,\n        data: Optional[Dict[str, Any]] = None,\n        audience: Optional[StrOrSeq] = None,\n        **kwargs\n    ) -&gt; str:\n        \"\"\"Generate a token\n\n        Args:\n            uid (str): Unique identifier to generate token for\n            type (str): Token type\n            fresh (bool, optional): Generate fresh token. Defaults to False.\n            headers (Optional[Dict[str, Any]], optional): TODO. Defaults to None.\n            expiry (Optional[DateTimeExpression], optional): User defined expiry claim.\n                Defaults to None.\n            data (Optional[Dict[str, Any]], optional): Additional data store in token.\n                Defaults to None.\n            audience (Optional[StrOrSeq], optional): Audience claim. Defaults to None.\n\n        Returns:\n            str: Token with encoded payload\n        \"\"\"\n        payload = self._create_payload(\n            uid=uid,\n            type=type,\n            fresh=fresh,\n            expiry=expiry,\n            data=data,\n            audience=audience,\n            **kwargs\n        )\n        token = payload.encode(\n            key=self.config.PRIVATE_KEY,\n            algorithm=self.config.JWT_ALGORITHM,\n            headers=headers,\n        )\n\n        return token\n\n    def _decode_token(\n        self,\n        token: str,\n        verify: bool = True,\n        audience: Optional[StrOrSeq] = None,\n        issuer: Optional[str] = None,\n    ) -&gt; TokenPayload:\n        \"\"\"Decode a token\n\n        Args:\n            token (str): Encoded token\n            verify (bool, optional): Apply verification. Defaults to True.\n            audience (Optional[StrOrSeq], optional): Audience claim. Defaults to None.\n            issuer (Optional[str], optional): Issuer claim. Defaults to None.\n\n        Returns:\n            TokenPayload: Token Payload instance\n        \"\"\"\n        return TokenPayload.decode(\n            token=token,\n            key=self.config.PUBLIC_KEY,\n            algorithms=[self.config.JWT_ALGORITHM],\n            verify=verify,\n            audience=audience if audience else self.config.JWT_DECODE_AUDIENCE,\n            issuer=issuer if issuer else self.config.JWT_DECODE_ISSUER,\n        )\n\n    def _set_cookies(\n        self,\n        token: str,\n        type: str,\n        response: Response,\n        max_age: Optional[int] = None,\n        *args,\n        **kwargs\n    ) -&gt; None:\n        if type == \"access\":\n            token_key = self.config.JWT_ACCESS_COOKIE_NAME\n            token_path = self.config.JWT_ACCESS_COOKIE_PATH\n            csrf_key = self.config.JWT_ACCESS_CSRF_COOKIE_NAME\n            csrf_path = self.config.JWT_ACCESS_CSRF_COOKIE_PATH\n        elif type == \"refresh\":\n            token_key = self.config.JWT_REFRESH_COOKIE_NAME\n            token_path = self.config.JWT_REFRESH_COOKIE_PATH\n            csrf_key = self.config.JWT_REFRESH_CSRF_COOKIE_NAME\n            csrf_path = self.config.JWT_REFRESH_CSRF_COOKIE_PATH\n        else:\n            raise ValueError(\"Token type must be 'access' | 'refresh'\")\n\n        # Set cookie\n        response.set_cookie(\n            key=token_key,\n            value=token,\n            path=token_path,\n            domain=self.config.JWT_COOKIE_DOMAIN,\n            samesite=self.config.JWT_COOKIE_SAMESITE,\n            secure=self.config.JWT_COOKIE_SECURE,\n            httponly=True,\n            max_age=max_age if max_age else self.config.JWT_COOKIE_MAX_AGE,\n        )\n        # Set CSRF\n        if self.config.JWT_COOKIE_CSRF_PROTECT and self.config.JWT_CSRF_IN_COOKIES:\n            response.set_cookie(\n                key=csrf_key,\n                value=self._decode_token(token=token, verify=True).csrf,\n                path=csrf_path,\n                domain=self.config.JWT_COOKIE_DOMAIN,\n                samesite=self.config.JWT_COOKIE_SAMESITE,\n                secure=self.config.JWT_COOKIE_SECURE,\n                httponly=False,\n                max_age=max_age if max_age else self.config.JWT_COOKIE_MAX_AGE,\n            )\n\n    def _unset_cookies(\n        self,\n        type: str,\n        response: Response,\n    ) -&gt; None:\n        if type == \"access\":\n            token_key = self.config.JWT_ACCESS_COOKIE_NAME\n            token_path = self.config.JWT_ACCESS_COOKIE_PATH\n            csrf_key = self.config.JWT_ACCESS_CSRF_COOKIE_NAME\n            csrf_path = self.config.JWT_ACCESS_CSRF_COOKIE_PATH\n        elif type == \"refresh\":\n            token_key = self.config.JWT_REFRESH_COOKIE_NAME\n            token_path = self.config.JWT_REFRESH_COOKIE_PATH\n            csrf_key = self.config.JWT_REFRESH_CSRF_COOKIE_NAME\n            csrf_path = self.config.JWT_REFRESH_CSRF_COOKIE_PATH\n        else:\n            raise ValueError(\"Token type must be 'access' | 'refresh'\")\n        # Unset cookie\n        response.delete_cookie(\n            key=token_key,\n            path=token_path,\n            domain=self.config.JWT_COOKIE_DOMAIN,\n        )\n        if self.config.JWT_COOKIE_CSRF_PROTECT and self.config.JWT_CSRF_IN_COOKIES:\n            response.delete_cookie(\n                key=csrf_key,\n                path=csrf_path,\n                domain=self.config.JWT_COOKIE_DOMAIN,\n            )\n\n    @overload\n    async def _get_token_from_request(  # noqa: E704\n        self,\n        request: Request,\n        locations: Optional[TokenLocations] = None,\n        refresh: bool = False,\n        optional: Literal[False] = False,\n    ) -&gt; RequestToken: ...\n\n    @overload\n    async def _get_token_from_request(  # noqa: E704\n        self,\n        request: Request,\n        locations: Optional[TokenLocations] = None,\n        refresh: bool = False,\n        optional: Literal[True] = True,\n    ) -&gt; Optional[RequestToken]: ...\n\n    async def _get_token_from_request(\n        self,\n        request: Request,\n        locations: Optional[TokenLocations] = None,\n        refresh: bool = False,\n        optional: bool = False,\n    ) -&gt; Optional[RequestToken]:\n        if refresh and locations is None:\n            locations = list(\n                set(self.config.JWT_TOKEN_LOCATION).intersection([\"cookies\", \"json\"])\n            )\n        elif (not refresh) and locations is None:\n            locations = list(self.config.JWT_TOKEN_LOCATION)\n        try:\n            token = await _get_token_from_request(\n                request=request,\n                refresh=refresh,\n                locations=locations,\n                config=self.config,\n            )\n            return token\n        except MissingTokenError as e:\n            if optional:\n                return None\n            raise e\n\n    async def get_access_token_from_request(self, request: Request) -&gt; RequestToken:\n        \"\"\"Dependency to retrieve access token from request\n\n        Args:\n            request (Request): Request to retrieve access token from\n\n        Raises:\n            MissingTokenError: When no `access` token is available in request\n\n        Returns:\n            RequestToken: Request Token instance for `access` token type\n        \"\"\"\n        return await self._get_token_from_request(request, optional=False)\n\n    async def get_refresh_token_from_request(self, request: Request) -&gt; RequestToken:\n        \"\"\"Dependency to retrieve refresh token from request\n\n        Args:\n            request (Request): Request to retrieve refresh token from\n\n        Raises:\n            MissingTokenError: When no `refresh` token is available in request\n\n        Returns:\n            RequestToken: Request Token instance for `refresh` token type\n        \"\"\"\n        return await self._get_token_from_request(request, refresh=True, optional=False)\n\n    async def _auth_required(\n        self,\n        request: Request,\n        type: str = \"access\",\n        verify_type: bool = True,\n        verify_fresh: bool = False,\n        verify_csrf: Optional[bool] = None,\n    ) -&gt; TokenPayload:\n        if type == \"access\":\n            method = self.get_access_token_from_request\n        elif type == \"refresh\":\n            method = self.get_refresh_token_from_request\n        else:\n            ...\n        if verify_csrf is None:\n            verify_csrf = self.config.JWT_COOKIE_CSRF_PROTECT and (\n                request.method.upper() in self.config.JWT_CSRF_METHODS\n            )\n\n        request_token = await method(\n            request=request,\n        )\n\n        if self.is_token_in_blocklist(request_token.token):\n            raise RevokedTokenError(\"Token has been revoked\")\n\n        return self.verify_token(\n            request_token,\n            verify_type=verify_type,\n            verify_fresh=verify_fresh,\n            verify_csrf=verify_csrf,\n        )\n\n    # endregion\n\n    # region Token methods\n\n    def verify_token(\n        self,\n        token: RequestToken,\n        verify_type: bool = True,\n        verify_fresh: bool = False,\n        verify_csrf: bool = True,\n    ) -&gt; TokenPayload:\n        \"\"\"Verify a request token\n\n        Args:\n            token (RequestToken): RequestToken instance\n            verify_type (bool, optional): Apply token type verification.\n                Defaults to True\n            verify_fresh (bool, optional): Apply token freshness verification.\n                Defaults to False\n            verify_csrf (bool, optional): Apply token CSRF verification.\n                Defaults to True\n\n        Returns:\n            TokenPayload: _description_\n        \"\"\"\n        return token.verify(\n            key=self.config.PUBLIC_KEY,\n            algorithms=[self.config.JWT_ALGORITHM],\n            verify_fresh=verify_fresh,\n            verify_type=verify_type,\n            verify_csrf=verify_csrf,\n        )\n\n    def create_access_token(\n        self,\n        uid: str,\n        fresh: bool = False,\n        headers: Optional[Dict[str, Any]] = None,\n        expiry: Optional[DateTimeExpression] = None,\n        data: Optional[Dict[str, Any]] = None,\n        audience: Optional[StrOrSeq] = None,\n        *args,\n        **kwargs\n    ) -&gt; str:\n        \"\"\"Generate an Access Token\n\n        Args:\n            uid (str): Unique identifier to generate token for\n            fresh (bool, optional): Generate fresh token. Defaults to False.\n            headers (Dict[str, Any], optional): TODO. Defaults to None.\n            expiry (DateTimeExpression, optional): User defined expiry claim.\n                Defaults to None.\n            data (Dict[str, Any], optional): Additional data store in token.\n                Defaults to None.\n            audience (StrOrSeq, optional): Audience claim. Defaults to None.\n\n        Returns:\n            str: Access Token\n        \"\"\"\n        return self._create_token(\n            uid=uid,\n            type=\"access\",\n            fresh=fresh,\n            headers=headers,\n            expiry=expiry,\n            data=data,\n            audience=audience,\n        )\n\n    def create_refresh_token(\n        self,\n        uid: str,\n        headers: Optional[Dict[str, Any]] = None,\n        expiry: Optional[DateTimeExpression] = None,\n        data: Optional[Dict[str, Any]] = None,\n        audience: Optional[StrOrSeq] = None,\n        *args,\n        **kwargs\n    ) -&gt; str:\n        \"\"\"Generate a refresh token\n\n        Args:\n            uid (str): Unique identifier to generate token for\n            headers (Dict[str, Any], optional): TODO. Defaults to None.\n            expiry (DateTimeExpression, optional): User defined expiry claim.\n                Defaults to None.\n            data (Dict[str, Any], optional): Additional data store in token.\n                Defaults to None.\n            audience (StrOrSeq, optional): Audience claim.\n                Defaults to None.\n\n        Returns:\n            str: Refresh Token\n        \"\"\"\n        return self._create_token(\n            uid=uid,\n            type=\"refresh\",\n            headers=headers,\n            expiry=expiry,\n            data=data,\n            audience=audience,\n        )\n\n    # endregion\n\n    # region Cookie methods\n\n    def set_access_cookies(\n        self,\n        token: str,\n        response: Response,\n        max_age: Optional[int] = None,\n    ) -&gt; None:\n        \"\"\"Add 'Set-Cookie' for access token in response header\n\n        Args:\n            token (str): Access token\n            response (Response): Response to set cookie on\n            max_age (int, optional): Max Age cookie paramater.\n                Defaults to None\n        \"\"\"\n        self._set_cookies(\n            token=token, type=\"access\", response=response, max_age=max_age\n        )\n\n    def set_refresh_cookies(\n        self,\n        token: str,\n        response: Response,\n        max_age: Optional[int] = None,\n    ) -&gt; None:\n        \"\"\"Add 'Set-Cookie' for refresh token in response header\n\n        Args:\n            token (str): Refresh token\n            response (Response): Response to set cookie on\n            max_age (int, optional): Max Age cookie paramater.\n                Defaults to None\n        \"\"\"\n        self._set_cookies(\n            token=token, type=\"refresh\", response=response, max_age=max_age\n        )\n\n    def unset_access_cookies(\n        self,\n        response: Response,\n    ) -&gt; None:\n        \"\"\"Remove 'Set-Cookie' for access token in response header\n\n        Args:\n            response (Response): Response to remove cooke from\n        \"\"\"\n        self._unset_cookies(\"access\", response=response)\n\n    def unset_refresh_cookies(\n        self,\n        response: Response,\n    ) -&gt; None:\n        \"\"\"Remove 'Set-Cookie' for refresh token in response header\n\n        Args:\n            response (Response): response to remove cooke from\n        \"\"\"\n        self._unset_cookies(\"refresh\", response=response)\n\n    def unset_cookies(self, response: Response) -&gt; None:\n        \"\"\"Remove 'Set-Cookie' for tokens from response headers\n\n        Args:\n            response (Response): response to remove token cookies from\n        \"\"\"\n        self.unset_access_cookies(response)\n        self.unset_refresh_cookies(response)\n\n    # endregion\n\n    # region Dependencies\n\n    @property\n    def DEPENDENCY(self) -&gt; FastJWTDeps:\n        \"\"\"FastAPI Dependency to return a FastJWT sub-object within the route context\n\n        Note:\n            The FastJWTDeps is a utility class, to enable quick token operations\n            within the route logic. It provides methods to avoid addtional code\n            in your route that would be outside of the route logic\n\n            Such methods includes setting and unsetting cookies without the need\n            to generate a response object beforhand\n\n        Returns:\n            FastJWTDeps: The contextful FastJWT object\n        \"\"\"\n        return Depends(self.get_dependency)\n\n    @property\n    def BUNDLE(self) -&gt; FastJWTDeps:\n        \"\"\"FastAPI Dependency to return a FastJWT sub-object within the route context\n\n        Note:\n            The FastJWTDeps is a utility class, to enable quick token operations\n            within the route logic. It provides methods to avoid addtional code\n            in your route that would be outside of the route logic\n\n            Such methods includes setting and unsetting cookies without the need\n            to generate a response object beforhand\n\n        Returns:\n            FastJWTDeps: The contextful FastJWT object\n        \"\"\"\n        return self.DEPENDENCY\n\n    @property\n    def FRESH_REQUIRED(self) -&gt; TokenPayload:\n        \"\"\"FastAPI Dependency to enforce valid token availability in request\n\n        Returns:\n            TokenPayload: Valid token Payload\n        \"\"\"\n        return Depends(self.fresh_token_required)\n\n    @property\n    def ACCESS_REQUIRED(self) -&gt; TokenPayload:\n        \"\"\"FastAPI Dependency to enforce presence of an `access` token in request\n\n        Returns:\n            TokenPayload: Valid token Payload\n        \"\"\"\n        return Depends(self.access_token_required)\n\n    @property\n    def REFRESH_REQUIRED(self) -&gt; TokenPayload:\n        \"\"\"FastAPI Dependency to enforce presence of a `refresh` token in request\n\n        Returns:\n            TokenPayload: Valid token Payload\n        \"\"\"\n        return Depends(self.refresh_token_required)\n\n    @property\n    def ACCESS_TOKEN(self) -&gt; RequestToken:\n        \"\"\"FastAPI Dependency to retrieve access token from request\n\n        Returns:\n            RequestToken: Request Token instance\n        \"\"\"\n        return Depends(self.get_token_from_request(type=\"access\"))\n\n    @property\n    def REFRESH_TOKEN(self) -&gt; RequestToken:\n        \"\"\"FastAPI Dependency to retrieve refresh token from request\n\n        Returns:\n            RequestToken: Request Token instance\n        \"\"\"\n        return Depends(self.get_token_from_request(type=\"refresh\"))\n\n    @property\n    def CURRENT_SUBJECT(self) -&gt; T:\n        \"\"\"FastAPI Dependency to retrieve the current subject from request\n\n        Returns:\n            T: The current subject\n        \"\"\"\n        return Depends(self.get_current_subject)\n\n    # endregion\n\n    # region Getters\n\n    def get_dependency(self, request: Request, response: Response) -&gt; FastJWTDeps:\n        \"\"\"FastAPI Dependency to return a FastJWT sub-object within the route context\n\n        Args:\n            request (Request): Request context managed by FastAPI\n            response (Response): Response context managed by FastAPI\n\n        Note:\n            The FastJWTDeps is a utility class, to enable quick token operations\n            within the route logic. It provides methods to avoid addtional code\n            in your route that would be outside of the route logic\n\n            Such methods includes setting and unsetting cookies without the need\n            to generate a response object beforhand\n\n        Returns:\n            FastJWTDeps: The contextful FastJWT object\n        \"\"\"\n        return FastJWTDeps(self, request=request, response=response)\n\n    def token_required(\n        self,\n        type: str = \"access\",\n        verify_type: bool = True,\n        verify_fresh: bool = False,\n        verify_csrf: Optional[bool] = None,\n    ) -&gt; Callable[[Request], TokenPayload]:\n        \"\"\"Dependency to enforce valid token availability in request\n\n        Args:\n            type (str, optional): Require a given token type.\n                Defaults to \"access\"\n            verify_type (bool, optional): Apply type verification.\n                Defaults to True\n            verify_fresh (bool, optional): Require token freshness.\n                Defaults to False\n            verify_csrf (Optional[bool], optional): Enable CSRF verification.\n                Defaults to None\n\n        Returns:\n            Callable[[Request], TokenPayload]: Dependency for Valid token\n                Payload retrieval\n        \"\"\"\n\n        async def _auth_required(request: Request):\n            \"\"\"FastAPI Dependency to enforce valid token availability in request\"\"\"\n            return await self._auth_required(\n                request=request,\n                type=type,\n                verify_csrf=verify_csrf,\n                verify_type=verify_type,\n                verify_fresh=verify_fresh,\n            )\n\n        return _auth_required\n\n    @property\n    def fresh_token_required(self) -&gt; Callable[[Request], TokenPayload]:\n        \"\"\"FastAPI Dependency to enforce presence of a `fresh` `access`\n        token in request\"\"\"\n        return self.token_required(\n            type=\"access\",\n            verify_csrf=None,\n            verify_fresh=True,\n            verify_type=True,\n        )\n\n    @property\n    def access_token_required(self) -&gt; Callable[[Request], TokenPayload]:\n        \"\"\"FastAPI Dependency to enforce presence of an `access` token in request\"\"\"\n        return self.token_required(\n            type=\"access\",\n            verify_csrf=None,\n            verify_fresh=False,\n            verify_type=True,\n        )\n\n    @property\n    def refresh_token_required(self) -&gt; Callable[[Request], TokenPayload]:\n        \"\"\"FastAPI Dependency to enforce presence of a `refresh` token in request\"\"\"\n        return self.token_required(\n            type=\"refresh\",\n            verify_csrf=None,\n            verify_fresh=False,\n            verify_type=True,\n        )\n\n    async def get_current_subject(self, request: Request) -&gt; Optional[T]:\n        \"\"\"Get the current subject instance\n\n        Use the request's token to retrieve the subject instance.\n        Enforce a validation step to ensure the token is valid.\n\n        Args:\n            request (Request): Request to retrieve token from\n\n        Returns:\n            Optional[T]: Subject instance\n\n        Note:\n            This method will always return `None` if\n            `FastJWT.set_subject_getter` has not been set first.\n        \"\"\"\n        token: TokenPayload = await self._auth_required(request=request)\n        uid = token.sub\n        return self._get_current_subject(uid=uid)\n\n    def get_token_from_request(\n        self, type: TokenType = \"access\", optional: bool = True\n    ) -&gt; Optional[RequestToken]:\n        \"\"\"Return token from response if available\n\n        Args:\n            type (TokenType, optional): The type of token to retrieve from request.\n                Defaults to \"access\".\n            optional (bool, optional): Whether or not to enforce token presence\n                in request. Defaults to True.\n\n        Note:\n            When `optional=True`, the return value might be `None`\n            if no token is available in request\n\n            When `optional=False`, raises a MissingTokenError\n\n        Returns:\n            Optional[RequestToken]: The RequestToken if available\n        \"\"\"\n\n        async def _token_getter(request: Request):\n            \"\"\"FastAPI Dependency to retrieve token from request\"\"\"\n            return await self._get_token_from_request(\n                request, optional=optional, refresh=(type == \"refresh\")\n            )\n\n        return _token_getter\n\n    # endregion\n\n    # region Middlewares\n\n    def _implicit_refresh_enabled_for_request(self, request: Request) -&gt; bool:\n        \"\"\"Check if a request should implement implicit token refresh\n\n        Args:\n            request (Request): Request to check\n\n        Returns:\n            bool: True if request allows for refreshing access token\n        \"\"\"\n        if (\n            request.url.components.path\n            in self.config.JWT_IMPLICIT_REFRESH_ROUTE_EXCLUDE\n        ):\n            refresh = False\n        elif (\n            request.url.components.path\n            in self.config.JWT_IMPLICIT_REFRESH_ROUTE_INCLUDE\n        ):\n            refresh = True\n        elif request.method in self.config.JWT_IMPLICIT_REFRESH_METHOD_EXCLUDE:\n            refresh = False\n        elif request.method in self.config.JWT_IMPLICIT_REFRESH_METHOD_INCLUDE:\n            refresh = False\n        else:\n            refresh = True\n        return refresh\n\n    async def implicit_refresh_middleware(\n        self, request: Request, call_next: Coroutine\n    ) -&gt; Response:\n        \"\"\"FastAPI Middleware to enable token refresh for an APIRouter\n\n        Args:\n            request (Request): Incoming request\n            call_next (Coroutine): Endpoint logic to be called\n\n        Note:\n            This middleware is only based on `access` tokens.\n            Using implicit refresh mechanism makes use of `refresh`\n            tokens unnecessary.\n\n        Note:\n            The refreshed `access` token will not be considered as\n            `fresh`\n\n        Note:\n            The implicit refresh mechanism is only enabled\n            for authorization through cookies.\n\n        Returns:\n            Response: Response with update access token cookie if relevant\n        \"\"\"\n        response = await call_next(request)\n\n        request_condition = self.config.has_location(\n            \"cookies\"\n        ) and self._implicit_refresh_enabled_for_request(request)\n\n        if request_condition:\n            try:\n                # Refresh mechanism\n                token = await self._get_token_from_request(\n                    request=request,\n                    locations=[\"cookies\"],\n                    refresh=False,\n                    optional=False,\n                )\n                payload = self.verify_token(token, verify_fresh=False)\n                if (\n                    payload.time_until_expiry\n                    &lt; self.config.JWT_IMPLICIT_REFRESH_DELTATIME\n                ):\n                    new_token = self.create_access_token(\n                        uid=payload.sub, fresh=False, data=payload.extra_dict\n                    )\n                    self.set_access_cookies(new_token, response=response)\n            except FastJWTException:\n                pass\n\n        return response\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.ACCESS_REQUIRED","title":"<code>ACCESS_REQUIRED: TokenPayload</code>  <code>property</code>","text":"<p>FastAPI Dependency to enforce presence of an <code>access</code> token in request</p> <p>Returns:</p> Name Type Description <code>TokenPayload</code> <code>TokenPayload</code> <p>Valid token Payload</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.ACCESS_TOKEN","title":"<code>ACCESS_TOKEN: RequestToken</code>  <code>property</code>","text":"<p>FastAPI Dependency to retrieve access token from request</p> <p>Returns:</p> Name Type Description <code>RequestToken</code> <code>RequestToken</code> <p>Request Token instance</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.BUNDLE","title":"<code>BUNDLE: FastJWTDeps</code>  <code>property</code>","text":"<p>FastAPI Dependency to return a FastJWT sub-object within the route context</p> Note <p>The FastJWTDeps is a utility class, to enable quick token operations within the route logic. It provides methods to avoid addtional code in your route that would be outside of the route logic</p> <p>Such methods includes setting and unsetting cookies without the need to generate a response object beforhand</p> <p>Returns:</p> Name Type Description <code>FastJWTDeps</code> <code>FastJWTDeps</code> <p>The contextful FastJWT object</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.CURRENT_SUBJECT","title":"<code>CURRENT_SUBJECT: T</code>  <code>property</code>","text":"<p>FastAPI Dependency to retrieve the current subject from request</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The current subject</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.DEPENDENCY","title":"<code>DEPENDENCY: FastJWTDeps</code>  <code>property</code>","text":"<p>FastAPI Dependency to return a FastJWT sub-object within the route context</p> Note <p>The FastJWTDeps is a utility class, to enable quick token operations within the route logic. It provides methods to avoid addtional code in your route that would be outside of the route logic</p> <p>Such methods includes setting and unsetting cookies without the need to generate a response object beforhand</p> <p>Returns:</p> Name Type Description <code>FastJWTDeps</code> <code>FastJWTDeps</code> <p>The contextful FastJWT object</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.FRESH_REQUIRED","title":"<code>FRESH_REQUIRED: TokenPayload</code>  <code>property</code>","text":"<p>FastAPI Dependency to enforce valid token availability in request</p> <p>Returns:</p> Name Type Description <code>TokenPayload</code> <code>TokenPayload</code> <p>Valid token Payload</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.REFRESH_REQUIRED","title":"<code>REFRESH_REQUIRED: TokenPayload</code>  <code>property</code>","text":"<p>FastAPI Dependency to enforce presence of a <code>refresh</code> token in request</p> <p>Returns:</p> Name Type Description <code>TokenPayload</code> <code>TokenPayload</code> <p>Valid token Payload</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.REFRESH_TOKEN","title":"<code>REFRESH_TOKEN: RequestToken</code>  <code>property</code>","text":"<p>FastAPI Dependency to retrieve refresh token from request</p> <p>Returns:</p> Name Type Description <code>RequestToken</code> <code>RequestToken</code> <p>Request Token instance</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.access_token_required","title":"<code>access_token_required: Callable[[Request], TokenPayload]</code>  <code>property</code>","text":"<p>FastAPI Dependency to enforce presence of an <code>access</code> token in request</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.config","title":"<code>config: FJWTConfig</code>  <code>property</code>","text":"<p>FastJWT Configuration getter</p> <p>Returns:</p> Name Type Description <code>FJWTConfig</code> <code>FJWTConfig</code> <p>Configuration BaseSettings</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.fresh_token_required","title":"<code>fresh_token_required: Callable[[Request], TokenPayload]</code>  <code>property</code>","text":"<p>FastAPI Dependency to enforce presence of a <code>fresh</code> <code>access</code> token in request</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.refresh_token_required","title":"<code>refresh_token_required: Callable[[Request], TokenPayload]</code>  <code>property</code>","text":"<p>FastAPI Dependency to enforce presence of a <code>refresh</code> token in request</p>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.__init__","title":"<code>__init__(config=FJWTConfig(), model=Dict[str, Any])</code>","text":"<p>FastJWT base object</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>FJWTConfig</code> <p>Configuration instance to use. Defaults to FJWTConfig()</p> <code>FJWTConfig()</code> <code>model</code> <code>Optional[T]</code> <p>Model type hint. Defaults to Dict[str, Any]</p> <code>Dict[str, Any]</code> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def __init__(\n    self, config: FJWTConfig = FJWTConfig(), model: Optional[T] = Dict[str, Any]\n) -&gt; None:\n    \"\"\"FastJWT base object\n\n    Args:\n        config (FJWTConfig, optional): Configuration instance to use.\n            Defaults to FJWTConfig()\n        model (Optional[T], optional): Model type hint.\n            Defaults to Dict[str, Any]\n    \"\"\"\n    super().__init__(model=model)\n    super(_CallbackHandler, self).__init__()\n    self._config = config\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.create_access_token","title":"<code>create_access_token(uid, fresh=False, headers=None, expiry=None, data=None, audience=None, *args, **kwargs)</code>","text":"<p>Generate an Access Token</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>Unique identifier to generate token for</p> required <code>fresh</code> <code>bool</code> <p>Generate fresh token. Defaults to False.</p> <code>False</code> <code>headers</code> <code>Dict[str, Any]</code> <p>TODO. Defaults to None.</p> <code>None</code> <code>expiry</code> <code>DateTimeExpression</code> <p>User defined expiry claim. Defaults to None.</p> <code>None</code> <code>data</code> <code>Dict[str, Any]</code> <p>Additional data store in token. Defaults to None.</p> <code>None</code> <code>audience</code> <code>StrOrSeq</code> <p>Audience claim. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Access Token</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def create_access_token(\n    self,\n    uid: str,\n    fresh: bool = False,\n    headers: Optional[Dict[str, Any]] = None,\n    expiry: Optional[DateTimeExpression] = None,\n    data: Optional[Dict[str, Any]] = None,\n    audience: Optional[StrOrSeq] = None,\n    *args,\n    **kwargs\n) -&gt; str:\n    \"\"\"Generate an Access Token\n\n    Args:\n        uid (str): Unique identifier to generate token for\n        fresh (bool, optional): Generate fresh token. Defaults to False.\n        headers (Dict[str, Any], optional): TODO. Defaults to None.\n        expiry (DateTimeExpression, optional): User defined expiry claim.\n            Defaults to None.\n        data (Dict[str, Any], optional): Additional data store in token.\n            Defaults to None.\n        audience (StrOrSeq, optional): Audience claim. Defaults to None.\n\n    Returns:\n        str: Access Token\n    \"\"\"\n    return self._create_token(\n        uid=uid,\n        type=\"access\",\n        fresh=fresh,\n        headers=headers,\n        expiry=expiry,\n        data=data,\n        audience=audience,\n    )\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.create_refresh_token","title":"<code>create_refresh_token(uid, headers=None, expiry=None, data=None, audience=None, *args, **kwargs)</code>","text":"<p>Generate a refresh token</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>str</code> <p>Unique identifier to generate token for</p> required <code>headers</code> <code>Dict[str, Any]</code> <p>TODO. Defaults to None.</p> <code>None</code> <code>expiry</code> <code>DateTimeExpression</code> <p>User defined expiry claim. Defaults to None.</p> <code>None</code> <code>data</code> <code>Dict[str, Any]</code> <p>Additional data store in token. Defaults to None.</p> <code>None</code> <code>audience</code> <code>StrOrSeq</code> <p>Audience claim. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Refresh Token</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def create_refresh_token(\n    self,\n    uid: str,\n    headers: Optional[Dict[str, Any]] = None,\n    expiry: Optional[DateTimeExpression] = None,\n    data: Optional[Dict[str, Any]] = None,\n    audience: Optional[StrOrSeq] = None,\n    *args,\n    **kwargs\n) -&gt; str:\n    \"\"\"Generate a refresh token\n\n    Args:\n        uid (str): Unique identifier to generate token for\n        headers (Dict[str, Any], optional): TODO. Defaults to None.\n        expiry (DateTimeExpression, optional): User defined expiry claim.\n            Defaults to None.\n        data (Dict[str, Any], optional): Additional data store in token.\n            Defaults to None.\n        audience (StrOrSeq, optional): Audience claim.\n            Defaults to None.\n\n    Returns:\n        str: Refresh Token\n    \"\"\"\n    return self._create_token(\n        uid=uid,\n        type=\"refresh\",\n        headers=headers,\n        expiry=expiry,\n        data=data,\n        audience=audience,\n    )\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.get_access_token_from_request","title":"<code>get_access_token_from_request(request)</code>  <code>async</code>","text":"<p>Dependency to retrieve access token from request</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>Request to retrieve access token from</p> required <p>Raises:</p> Type Description <code>MissingTokenError</code> <p>When no <code>access</code> token is available in request</p> <p>Returns:</p> Name Type Description <code>RequestToken</code> <code>RequestToken</code> <p>Request Token instance for <code>access</code> token type</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>async def get_access_token_from_request(self, request: Request) -&gt; RequestToken:\n    \"\"\"Dependency to retrieve access token from request\n\n    Args:\n        request (Request): Request to retrieve access token from\n\n    Raises:\n        MissingTokenError: When no `access` token is available in request\n\n    Returns:\n        RequestToken: Request Token instance for `access` token type\n    \"\"\"\n    return await self._get_token_from_request(request, optional=False)\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.get_current_subject","title":"<code>get_current_subject(request)</code>  <code>async</code>","text":"<p>Get the current subject instance</p> <p>Use the request's token to retrieve the subject instance. Enforce a validation step to ensure the token is valid.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>Request to retrieve token from</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Optional[T]: Subject instance</p> Note <p>This method will always return <code>None</code> if <code>FastJWT.set_subject_getter</code> has not been set first.</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>async def get_current_subject(self, request: Request) -&gt; Optional[T]:\n    \"\"\"Get the current subject instance\n\n    Use the request's token to retrieve the subject instance.\n    Enforce a validation step to ensure the token is valid.\n\n    Args:\n        request (Request): Request to retrieve token from\n\n    Returns:\n        Optional[T]: Subject instance\n\n    Note:\n        This method will always return `None` if\n        `FastJWT.set_subject_getter` has not been set first.\n    \"\"\"\n    token: TokenPayload = await self._auth_required(request=request)\n    uid = token.sub\n    return self._get_current_subject(uid=uid)\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.get_dependency","title":"<code>get_dependency(request, response)</code>","text":"<p>FastAPI Dependency to return a FastJWT sub-object within the route context</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>Request context managed by FastAPI</p> required <code>response</code> <code>Response</code> <p>Response context managed by FastAPI</p> required Note <p>The FastJWTDeps is a utility class, to enable quick token operations within the route logic. It provides methods to avoid addtional code in your route that would be outside of the route logic</p> <p>Such methods includes setting and unsetting cookies without the need to generate a response object beforhand</p> <p>Returns:</p> Name Type Description <code>FastJWTDeps</code> <code>FastJWTDeps</code> <p>The contextful FastJWT object</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def get_dependency(self, request: Request, response: Response) -&gt; FastJWTDeps:\n    \"\"\"FastAPI Dependency to return a FastJWT sub-object within the route context\n\n    Args:\n        request (Request): Request context managed by FastAPI\n        response (Response): Response context managed by FastAPI\n\n    Note:\n        The FastJWTDeps is a utility class, to enable quick token operations\n        within the route logic. It provides methods to avoid addtional code\n        in your route that would be outside of the route logic\n\n        Such methods includes setting and unsetting cookies without the need\n        to generate a response object beforhand\n\n    Returns:\n        FastJWTDeps: The contextful FastJWT object\n    \"\"\"\n    return FastJWTDeps(self, request=request, response=response)\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.get_refresh_token_from_request","title":"<code>get_refresh_token_from_request(request)</code>  <code>async</code>","text":"<p>Dependency to retrieve refresh token from request</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>Request to retrieve refresh token from</p> required <p>Raises:</p> Type Description <code>MissingTokenError</code> <p>When no <code>refresh</code> token is available in request</p> <p>Returns:</p> Name Type Description <code>RequestToken</code> <code>RequestToken</code> <p>Request Token instance for <code>refresh</code> token type</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>async def get_refresh_token_from_request(self, request: Request) -&gt; RequestToken:\n    \"\"\"Dependency to retrieve refresh token from request\n\n    Args:\n        request (Request): Request to retrieve refresh token from\n\n    Raises:\n        MissingTokenError: When no `refresh` token is available in request\n\n    Returns:\n        RequestToken: Request Token instance for `refresh` token type\n    \"\"\"\n    return await self._get_token_from_request(request, refresh=True, optional=False)\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.get_token_from_request","title":"<code>get_token_from_request(type='access', optional=True)</code>","text":"<p>Return token from response if available</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>TokenType</code> <p>The type of token to retrieve from request. Defaults to \"access\".</p> <code>'access'</code> <code>optional</code> <code>bool</code> <p>Whether or not to enforce token presence in request. Defaults to True.</p> <code>True</code> Note <p>When <code>optional=True</code>, the return value might be <code>None</code> if no token is available in request</p> <p>When <code>optional=False</code>, raises a MissingTokenError</p> <p>Returns:</p> Type Description <code>Optional[RequestToken]</code> <p>Optional[RequestToken]: The RequestToken if available</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def get_token_from_request(\n    self, type: TokenType = \"access\", optional: bool = True\n) -&gt; Optional[RequestToken]:\n    \"\"\"Return token from response if available\n\n    Args:\n        type (TokenType, optional): The type of token to retrieve from request.\n            Defaults to \"access\".\n        optional (bool, optional): Whether or not to enforce token presence\n            in request. Defaults to True.\n\n    Note:\n        When `optional=True`, the return value might be `None`\n        if no token is available in request\n\n        When `optional=False`, raises a MissingTokenError\n\n    Returns:\n        Optional[RequestToken]: The RequestToken if available\n    \"\"\"\n\n    async def _token_getter(request: Request):\n        \"\"\"FastAPI Dependency to retrieve token from request\"\"\"\n        return await self._get_token_from_request(\n            request, optional=optional, refresh=(type == \"refresh\")\n        )\n\n    return _token_getter\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.implicit_refresh_middleware","title":"<code>implicit_refresh_middleware(request, call_next)</code>  <code>async</code>","text":"<p>FastAPI Middleware to enable token refresh for an APIRouter</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>Incoming request</p> required <code>call_next</code> <code>Coroutine</code> <p>Endpoint logic to be called</p> required Note <p>This middleware is only based on <code>access</code> tokens. Using implicit refresh mechanism makes use of <code>refresh</code> tokens unnecessary.</p> Note <p>The refreshed <code>access</code> token will not be considered as <code>fresh</code></p> Note <p>The implicit refresh mechanism is only enabled for authorization through cookies.</p> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Response with update access token cookie if relevant</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>async def implicit_refresh_middleware(\n    self, request: Request, call_next: Coroutine\n) -&gt; Response:\n    \"\"\"FastAPI Middleware to enable token refresh for an APIRouter\n\n    Args:\n        request (Request): Incoming request\n        call_next (Coroutine): Endpoint logic to be called\n\n    Note:\n        This middleware is only based on `access` tokens.\n        Using implicit refresh mechanism makes use of `refresh`\n        tokens unnecessary.\n\n    Note:\n        The refreshed `access` token will not be considered as\n        `fresh`\n\n    Note:\n        The implicit refresh mechanism is only enabled\n        for authorization through cookies.\n\n    Returns:\n        Response: Response with update access token cookie if relevant\n    \"\"\"\n    response = await call_next(request)\n\n    request_condition = self.config.has_location(\n        \"cookies\"\n    ) and self._implicit_refresh_enabled_for_request(request)\n\n    if request_condition:\n        try:\n            # Refresh mechanism\n            token = await self._get_token_from_request(\n                request=request,\n                locations=[\"cookies\"],\n                refresh=False,\n                optional=False,\n            )\n            payload = self.verify_token(token, verify_fresh=False)\n            if (\n                payload.time_until_expiry\n                &lt; self.config.JWT_IMPLICIT_REFRESH_DELTATIME\n            ):\n                new_token = self.create_access_token(\n                    uid=payload.sub, fresh=False, data=payload.extra_dict\n                )\n                self.set_access_cookies(new_token, response=response)\n        except FastJWTException:\n            pass\n\n    return response\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.load_config","title":"<code>load_config(config)</code>","text":"<p>Loads a FJWTConfig as the new configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>FJWTConfig</code> <p>Configuration to load</p> required Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def load_config(self, config: FJWTConfig) -&gt; None:\n    \"\"\"Loads a FJWTConfig as the new configuration\n\n    Args:\n        config (FJWTConfig): Configuration to load\n    \"\"\"\n    self._config = config\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.set_access_cookies","title":"<code>set_access_cookies(token, response, max_age=None)</code>","text":"<p>Add 'Set-Cookie' for access token in response header</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>response</code> <code>Response</code> <p>Response to set cookie on</p> required <code>max_age</code> <code>int</code> <p>Max Age cookie paramater. Defaults to None</p> <code>None</code> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def set_access_cookies(\n    self,\n    token: str,\n    response: Response,\n    max_age: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Add 'Set-Cookie' for access token in response header\n\n    Args:\n        token (str): Access token\n        response (Response): Response to set cookie on\n        max_age (int, optional): Max Age cookie paramater.\n            Defaults to None\n    \"\"\"\n    self._set_cookies(\n        token=token, type=\"access\", response=response, max_age=max_age\n    )\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.set_refresh_cookies","title":"<code>set_refresh_cookies(token, response, max_age=None)</code>","text":"<p>Add 'Set-Cookie' for refresh token in response header</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Refresh token</p> required <code>response</code> <code>Response</code> <p>Response to set cookie on</p> required <code>max_age</code> <code>int</code> <p>Max Age cookie paramater. Defaults to None</p> <code>None</code> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def set_refresh_cookies(\n    self,\n    token: str,\n    response: Response,\n    max_age: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Add 'Set-Cookie' for refresh token in response header\n\n    Args:\n        token (str): Refresh token\n        response (Response): Response to set cookie on\n        max_age (int, optional): Max Age cookie paramater.\n            Defaults to None\n    \"\"\"\n    self._set_cookies(\n        token=token, type=\"refresh\", response=response, max_age=max_age\n    )\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.token_required","title":"<code>token_required(type='access', verify_type=True, verify_fresh=False, verify_csrf=None)</code>","text":"<p>Dependency to enforce valid token availability in request</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>Require a given token type. Defaults to \"access\"</p> <code>'access'</code> <code>verify_type</code> <code>bool</code> <p>Apply type verification. Defaults to True</p> <code>True</code> <code>verify_fresh</code> <code>bool</code> <p>Require token freshness. Defaults to False</p> <code>False</code> <code>verify_csrf</code> <code>Optional[bool]</code> <p>Enable CSRF verification. Defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Request], TokenPayload]</code> <p>Callable[[Request], TokenPayload]: Dependency for Valid token Payload retrieval</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def token_required(\n    self,\n    type: str = \"access\",\n    verify_type: bool = True,\n    verify_fresh: bool = False,\n    verify_csrf: Optional[bool] = None,\n) -&gt; Callable[[Request], TokenPayload]:\n    \"\"\"Dependency to enforce valid token availability in request\n\n    Args:\n        type (str, optional): Require a given token type.\n            Defaults to \"access\"\n        verify_type (bool, optional): Apply type verification.\n            Defaults to True\n        verify_fresh (bool, optional): Require token freshness.\n            Defaults to False\n        verify_csrf (Optional[bool], optional): Enable CSRF verification.\n            Defaults to None\n\n    Returns:\n        Callable[[Request], TokenPayload]: Dependency for Valid token\n            Payload retrieval\n    \"\"\"\n\n    async def _auth_required(request: Request):\n        \"\"\"FastAPI Dependency to enforce valid token availability in request\"\"\"\n        return await self._auth_required(\n            request=request,\n            type=type,\n            verify_csrf=verify_csrf,\n            verify_type=verify_type,\n            verify_fresh=verify_fresh,\n        )\n\n    return _auth_required\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.unset_access_cookies","title":"<code>unset_access_cookies(response)</code>","text":"<p>Remove 'Set-Cookie' for access token in response header</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Response to remove cooke from</p> required Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def unset_access_cookies(\n    self,\n    response: Response,\n) -&gt; None:\n    \"\"\"Remove 'Set-Cookie' for access token in response header\n\n    Args:\n        response (Response): Response to remove cooke from\n    \"\"\"\n    self._unset_cookies(\"access\", response=response)\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.unset_cookies","title":"<code>unset_cookies(response)</code>","text":"<p>Remove 'Set-Cookie' for tokens from response headers</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>response to remove token cookies from</p> required Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def unset_cookies(self, response: Response) -&gt; None:\n    \"\"\"Remove 'Set-Cookie' for tokens from response headers\n\n    Args:\n        response (Response): response to remove token cookies from\n    \"\"\"\n    self.unset_access_cookies(response)\n    self.unset_refresh_cookies(response)\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.unset_refresh_cookies","title":"<code>unset_refresh_cookies(response)</code>","text":"<p>Remove 'Set-Cookie' for refresh token in response header</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>response to remove cooke from</p> required Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def unset_refresh_cookies(\n    self,\n    response: Response,\n) -&gt; None:\n    \"\"\"Remove 'Set-Cookie' for refresh token in response header\n\n    Args:\n        response (Response): response to remove cooke from\n    \"\"\"\n    self._unset_cookies(\"refresh\", response=response)\n</code></pre>"},{"location":"api/fastjwt/#fastjwt.fastjwt.FastJWT.verify_token","title":"<code>verify_token(token, verify_type=True, verify_fresh=False, verify_csrf=True)</code>","text":"<p>Verify a request token</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>RequestToken</code> <p>RequestToken instance</p> required <code>verify_type</code> <code>bool</code> <p>Apply token type verification. Defaults to True</p> <code>True</code> <code>verify_fresh</code> <code>bool</code> <p>Apply token freshness verification. Defaults to False</p> <code>False</code> <code>verify_csrf</code> <code>bool</code> <p>Apply token CSRF verification. Defaults to True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>TokenPayload</code> <code>TokenPayload</code> <p>description</p> Source code in <code>fastjwt/fastjwt.py</code> <pre><code>def verify_token(\n    self,\n    token: RequestToken,\n    verify_type: bool = True,\n    verify_fresh: bool = False,\n    verify_csrf: bool = True,\n) -&gt; TokenPayload:\n    \"\"\"Verify a request token\n\n    Args:\n        token (RequestToken): RequestToken instance\n        verify_type (bool, optional): Apply token type verification.\n            Defaults to True\n        verify_fresh (bool, optional): Apply token freshness verification.\n            Defaults to False\n        verify_csrf (bool, optional): Apply token CSRF verification.\n            Defaults to True\n\n    Returns:\n        TokenPayload: _description_\n    \"\"\"\n    return token.verify(\n        key=self.config.PUBLIC_KEY,\n        algorithms=[self.config.JWT_ALGORITHM],\n        verify_fresh=verify_fresh,\n        verify_type=verify_type,\n        verify_csrf=verify_csrf,\n    )\n</code></pre>"},{"location":"api/request_token/","title":"RequestToken","text":"<p>             Bases: <code>BaseModel</code></p> <p>Base model for token data retrieved from requests</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>TokenType</code> <p>Type of token. Defaults to access.</p> required <code>token</code> <code>Optional[str]</code> <p>The token retrieved from the request. Defaults to None.</p> required <code>csrf</code> <code>Optional[str]</code> <p>CSRF Value in request if detailed. Defaults to None.</p> required <code>location</code> <code>TokenLocation</code> <p>Where the token was found in request.</p> required Source code in <code>fastjwt/models.py</code> <pre><code>class RequestToken(BaseModel):\n    \"\"\"Base model for token data retrieved from requests\n\n    Args:\n        type (TokenType): Type of token. Defaults to access.\n        token (Optional[str]): The token retrieved from the request. Defaults to None.\n        csrf (Optional[str]): CSRF Value in request if detailed. Defaults to None.\n        location (TokenLocation): Where the token was found in request.\n    \"\"\"\n\n    token: Optional[str] = None\n    csrf: Optional[str] = None\n    type: TokenType = \"access\"\n    location: TokenLocation\n\n    def verify(\n        self,\n        key: str,\n        algorithms: Sequence[AlgorithmType] = [\"HS256\"],\n        audience: Optional[StrOrSeq] = None,\n        issuer: Optional[str] = None,\n        verify_jwt: bool = True,\n        verify_type: bool = True,\n        verify_csrf: bool = True,\n        verify_fresh: bool = False,\n    ) -&gt; TokenPayload:\n        \"\"\"Verify a RequestToken\n\n        Args:\n            key (str): Secret to decode the token\n            algorithms (Sequence[AlgorithmType], optional): Algorithms to use to decode the token. Defaults to [\"HS256\"].\n            audience (Optional[StrOrSeq], optional): Audience claim to verify. Defaults to None.\n            issuer (Optional[str], optional): Issuer claim to verify. Defaults to None.\n            verify_jwt (bool, optional): Enable base JWT verification. Defaults to True.\n            verify_type (bool, optional): Enable token type verification. Defaults to True.\n            verify_csrf (bool, optional): Enable CSRF verification. Defaults to True.\n            verify_fresh (bool, optional): Enable token freshness verification. Defaults to False.\n\n        Raises:\n            JWTDecodeError: Error while decoding the token\n            JWTDecodeError: The base JWT verification step has failed\n            FreshTokenRequiredError: The token is not fresh\n            CSRFError: A CSRF token is missing in the request\n            CSRFError: No CSRF claim is contained in the token\n            CSRFError: CSRF double submit does not match\n\n        Returns:\n            TokenPayload: The payload encoded in the token\n        \"\"\"\n        # JWT Base Verification\n        try:\n            decoded_token = decode_token(\n                token=self.token,\n                key=key,\n                algorithms=algorithms,\n                verify=verify_jwt,\n                audience=audience,\n                issuer=issuer,\n            )\n            # Parse payload\n            payload = TokenPayload.parse_obj(decoded_token)\n        except JWTDecodeError as e:\n            raise JWTDecodeError(*e.args)\n        except ValidationError as e:\n            raise JWTDecodeError(*e.args)\n\n        # TODO Verify Headers\n\n        if verify_type and (self.type != payload.type):\n            error_msg = f\"'{self.type}' token required, '{payload.type}' token received\"\n            if self.type == \"access\":\n                raise AccessTokenRequiredError(error_msg)\n            elif self.type == \"refresh\":\n                raise RefreshTokenRequiredError(error_msg)\n            raise TokenTypeError(error_msg)\n\n        if verify_fresh and not payload.fresh:\n            raise FreshTokenRequiredError(\"Fresh token required\")\n\n        if verify_csrf and self.location == \"cookies\":\n            if self.csrf is None:\n                raise CSRFError(\"Missing CSRF in request\")\n            if payload.csrf is None:\n                raise CSRFError(\"Missing 'csrf' claim\")\n            if not compare_digest(self.csrf, payload.csrf):\n                raise CSRFError(\"CSRF double submit does not match\")\n\n        return payload\n</code></pre>"},{"location":"api/request_token/#fastjwt.models.RequestToken.verify","title":"<code>verify(key, algorithms=['HS256'], audience=None, issuer=None, verify_jwt=True, verify_type=True, verify_csrf=True, verify_fresh=False)</code>","text":"<p>Verify a RequestToken</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Secret to decode the token</p> required <code>algorithms</code> <code>Sequence[AlgorithmType]</code> <p>Algorithms to use to decode the token. Defaults to [\"HS256\"].</p> <code>['HS256']</code> <code>audience</code> <code>Optional[StrOrSeq]</code> <p>Audience claim to verify. Defaults to None.</p> <code>None</code> <code>issuer</code> <code>Optional[str]</code> <p>Issuer claim to verify. Defaults to None.</p> <code>None</code> <code>verify_jwt</code> <code>bool</code> <p>Enable base JWT verification. Defaults to True.</p> <code>True</code> <code>verify_type</code> <code>bool</code> <p>Enable token type verification. Defaults to True.</p> <code>True</code> <code>verify_csrf</code> <code>bool</code> <p>Enable CSRF verification. Defaults to True.</p> <code>True</code> <code>verify_fresh</code> <code>bool</code> <p>Enable token freshness verification. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>JWTDecodeError</code> <p>Error while decoding the token</p> <code>JWTDecodeError</code> <p>The base JWT verification step has failed</p> <code>FreshTokenRequiredError</code> <p>The token is not fresh</p> <code>CSRFError</code> <p>A CSRF token is missing in the request</p> <code>CSRFError</code> <p>No CSRF claim is contained in the token</p> <code>CSRFError</code> <p>CSRF double submit does not match</p> <p>Returns:</p> Name Type Description <code>TokenPayload</code> <code>TokenPayload</code> <p>The payload encoded in the token</p> Source code in <code>fastjwt/models.py</code> <pre><code>def verify(\n    self,\n    key: str,\n    algorithms: Sequence[AlgorithmType] = [\"HS256\"],\n    audience: Optional[StrOrSeq] = None,\n    issuer: Optional[str] = None,\n    verify_jwt: bool = True,\n    verify_type: bool = True,\n    verify_csrf: bool = True,\n    verify_fresh: bool = False,\n) -&gt; TokenPayload:\n    \"\"\"Verify a RequestToken\n\n    Args:\n        key (str): Secret to decode the token\n        algorithms (Sequence[AlgorithmType], optional): Algorithms to use to decode the token. Defaults to [\"HS256\"].\n        audience (Optional[StrOrSeq], optional): Audience claim to verify. Defaults to None.\n        issuer (Optional[str], optional): Issuer claim to verify. Defaults to None.\n        verify_jwt (bool, optional): Enable base JWT verification. Defaults to True.\n        verify_type (bool, optional): Enable token type verification. Defaults to True.\n        verify_csrf (bool, optional): Enable CSRF verification. Defaults to True.\n        verify_fresh (bool, optional): Enable token freshness verification. Defaults to False.\n\n    Raises:\n        JWTDecodeError: Error while decoding the token\n        JWTDecodeError: The base JWT verification step has failed\n        FreshTokenRequiredError: The token is not fresh\n        CSRFError: A CSRF token is missing in the request\n        CSRFError: No CSRF claim is contained in the token\n        CSRFError: CSRF double submit does not match\n\n    Returns:\n        TokenPayload: The payload encoded in the token\n    \"\"\"\n    # JWT Base Verification\n    try:\n        decoded_token = decode_token(\n            token=self.token,\n            key=key,\n            algorithms=algorithms,\n            verify=verify_jwt,\n            audience=audience,\n            issuer=issuer,\n        )\n        # Parse payload\n        payload = TokenPayload.parse_obj(decoded_token)\n    except JWTDecodeError as e:\n        raise JWTDecodeError(*e.args)\n    except ValidationError as e:\n        raise JWTDecodeError(*e.args)\n\n    # TODO Verify Headers\n\n    if verify_type and (self.type != payload.type):\n        error_msg = f\"'{self.type}' token required, '{payload.type}' token received\"\n        if self.type == \"access\":\n            raise AccessTokenRequiredError(error_msg)\n        elif self.type == \"refresh\":\n            raise RefreshTokenRequiredError(error_msg)\n        raise TokenTypeError(error_msg)\n\n    if verify_fresh and not payload.fresh:\n        raise FreshTokenRequiredError(\"Fresh token required\")\n\n    if verify_csrf and self.location == \"cookies\":\n        if self.csrf is None:\n            raise CSRFError(\"Missing CSRF in request\")\n        if payload.csrf is None:\n            raise CSRFError(\"Missing 'csrf' claim\")\n        if not compare_digest(self.csrf, payload.csrf):\n            raise CSRFError(\"CSRF double submit does not match\")\n\n    return payload\n</code></pre>"},{"location":"api/token_payload/","title":"TokenPayload","text":"<p>             Bases: <code>BaseModel</code></p> <p>JWT Payload base model</p> <p>Parameters:</p> Name Type Description Default <code>jti</code> <code>Optional[str]</code> <p>JWT unique identifier. Defaults to UUID4.</p> required <code>iss</code> <code>Optional[str]</code> <p>JWT issuer. Defaults to None.</p> required <code>sub</code> <code>Optional[str]</code> <p>JWT subject. Defaults to None.</p> required <code>aud</code> <code>Optional[str]</code> <p>JWT audience. Defaults to None.</p> required <code>exp</code> <code>Numeric | DateTimeExpression | None</code> <p>Expiry date claim. Defaults to None.</p> required <code>nbf</code> <code>Numeric | DateTimeExpression | None</code> <p>Not before claim. Defaults to None.</p> required <code>iat</code> <code>Numeric | DateTimeExpression | None</code> <p>Issued at claim. Defaults to None.</p> required <code>type</code> <code>Optional[str]</code> <p>Token type. Default to None.</p> required <code>csrf</code> <code>Optional[str]</code> <p>CSRF double submit token. Default to None.</p> required <code>scopes</code> <code>Optional[List[str]]</code> <p>TODO.</p> required <code>fresh</code> <code>bool</code> <p>Token freshness state. Defaults to False.</p> required Source code in <code>fastjwt/models.py</code> <pre><code>class TokenPayload(BaseModel):\n    \"\"\"JWT Payload base model\n\n    Args:\n        jti (Optional[str]): JWT unique identifier. Defaults to UUID4.\n        iss (Optional[str]): JWT issuer. Defaults to None.\n        sub (Optional[str]): JWT subject. Defaults to None.\n        aud (Optional[str]): JWT audience. Defaults to None.\n        exp (Numeric | DateTimeExpression | None): Expiry date claim. Defaults to None.\n        nbf (Numeric | DateTimeExpression | None): Not before claim. Defaults to None.\n        iat (Numeric | DateTimeExpression | None): Issued at claim. Defaults to None.\n        type (Optional[str]): Token type. Default to None.\n        csrf (Optional[str]): CSRF double submit token. Default to None.\n        scopes (Optional[List[str]]): TODO.\n        fresh (bool): Token freshness state. Defaults to False.\n    \"\"\"\n\n    jti: Optional[str] = Field(default_factory=get_uuid)\n    iss: Optional[str] = None\n    sub: Optional[str] = None\n    aud: Optional[str] = None\n    exp: Optional[Union[Numeric, DateTimeExpression]] = None\n    nbf: Optional[Union[Numeric, DateTimeExpression]] = None\n    iat: Optional[Union[Numeric, DateTimeExpression]] = Field(\n        default_factory=lambda: int(get_now_ts())\n    )\n    type: Optional[str] = None\n    csrf: Optional[str] = None\n    scopes: Optional[List[str]] = None\n    fresh: bool = False\n\n    class Config:\n        extra = Extra.allow\n\n    @property\n    def _additional_fields(self) -&gt; set[str]:\n        return set(self.__dict__) - set(self.__fields__)\n\n    @property\n    def extra_dict(self):\n        return self.dict(include=self._additional_fields)\n\n    @property\n    def issued_at(self) -&gt; datetime.datetime:\n        \"\"\"Cast the 'iat' claim as a datetime.datetime\n\n        Raises:\n            TypeError: 'iat' claim is not of type float | int | datetime.datetime\n\n        Returns:\n            datetime.datetime: UTC Datetime token issued date\n        \"\"\"\n        if isinstance(self.iat, (float, int)):\n            return datetime.datetime.fromtimestamp(self.iat, tz=datetime.timezone.utc)\n        elif isinstance(self.iat, datetime.datetime):\n            return self.iat\n        else:\n            raise TypeError(\n                \"'iat' claim should be of type float | int | datetime.datetime\"\n            )\n\n    @property\n    def expiry_datetime(self) -&gt; datetime.datetime:\n        \"\"\"Cast the 'exp' claim as a datetime.datetime\n\n        Raises:\n            TypeError: 'exp' claim is not of type float | int | datetime.datetime | datetime.timedelta\n\n        Returns:\n            datetime.datetime: UTC Datetime token expiry date\n        \"\"\"\n        if isinstance(self.exp, datetime.datetime):\n            return self.exp\n        elif isinstance(self.exp, datetime.timedelta):\n            return self.issued_at + self.exp\n        elif isinstance(self.exp, (float, int)):\n            return datetime.datetime.fromtimestamp(self.exp, tz=datetime.timezone.utc)\n        else:\n            raise TypeError(\n                \"'exp' claim should be of type float | int | datetime.datetime | datetime.timedelta\"\n            )\n\n    @property\n    def time_until_expiry(self) -&gt; datetime.timedelta:\n        \"\"\"Return the time remaining until expiry\n\n        Returns:\n            datetime.timedelta: time remaining until expiry\n        \"\"\"\n        return self.expiry_datetime - get_now()\n\n    @property\n    def time_since_issued(self) -&gt; datetime.timedelta:\n        \"\"\"Return the time elapsed since token has been issued\n\n        Returns:\n            datetime.timedelta: time elapsed since token has been issued\n        \"\"\"\n        return get_now() - self.issued_at\n\n    @validator(\"exp\", \"nbf\", always=True)\n    def _set_default_ts(cls, value):\n        if isinstance(value, datetime.datetime):\n            return value.timestamp()\n        elif isinstance(value, datetime.timedelta):\n            return (get_now() + value).timestamp()\n        return value\n\n    def has_scopes(self, *scopes: Sequence[str]) -&gt; bool:\n        \"\"\"Checks if a given scope is contained within TokenPayload scopes\n\n        Args:\n            *scopes (Sequence[str]): scopes to verify\n\n        Returns:\n            bool: Whether the scopes are contained in the payload scopes\n        \"\"\"\n        return all([s in self.scopes for s in scopes])\n\n    def encode(\n        self,\n        key: str,\n        algorithm: str,\n        ignore_errors: bool = True,\n        headers: Optional[Dict[str, Any]] = None,\n    ) -&gt; str:\n        \"\"\"Encode the payload\n\n        Args:\n            key (str): Secret key to encode the payload\n            algorithm (str): Algorithm to use to encode the payload\n            ignore_errors (bool, optional): Ignore validation errors. Defaults to True.\n            headers (Optional[Dict[str, Any]], optional): TODO. Defaults to None.\n\n        Returns:\n            str: encoded token\n        \"\"\"\n        # TODO Handle Headers\n        # TODO Handle Extra fields\n        return create_token(\n            key=key,\n            algorithm=algorithm,\n            uid=self.sub,\n            jti=self.jti,\n            issued=self.iat,\n            type=self.type,\n            expiry=self.exp,\n            fresh=self.fresh,\n            csrf=self.csrf,\n            audience=self.aud,\n            issuer=self.iss,\n            not_before=self.nbf,\n            ignore_errors=ignore_errors,\n            headers=headers,\n        )\n\n    @classmethod\n    def decode(\n        cls,\n        token: str,\n        key: str,\n        algorithms: Sequence[AlgorithmType] = [\"HS256\"],\n        audience: Optional[StrOrSeq] = None,\n        issuer: Optional[str] = None,\n        verify: bool = True,\n    ) -&gt; \"TokenPayload\":\n        \"\"\"Given a token returns the associated JWT payload\n\n        Args:\n            token (str): Token to decode\n            key (str): Secret to decode the token\n            algorithms (Sequence[AlgorithmType], optional): Algorithms to use to decode the token. Defaults to [\"HS256\"].\n            audience (Optional[StrOrSeq], optional): Audience to verify. Defaults to None.\n            issuer (Optional[str], optional): Issuer to verify. Defaults to None.\n            verify (bool, optional): Enable verification. Defaults to True.\n\n        Returns:\n            TokenPayload: The decoded JWT payload\n        \"\"\"\n        payload = decode_token(\n            token=token,\n            key=key,\n            algorithms=algorithms,\n            audience=audience,\n            issuer=issuer,\n            verify=verify,\n        )\n        return cls.parse_obj(payload)\n</code></pre>"},{"location":"api/token_payload/#fastjwt.models.TokenPayload.expiry_datetime","title":"<code>expiry_datetime: datetime.datetime</code>  <code>property</code>","text":"<p>Cast the 'exp' claim as a datetime.datetime</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>'exp' claim is not of type float | int | datetime.datetime | datetime.timedelta</p> <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: UTC Datetime token expiry date</p>"},{"location":"api/token_payload/#fastjwt.models.TokenPayload.issued_at","title":"<code>issued_at: datetime.datetime</code>  <code>property</code>","text":"<p>Cast the 'iat' claim as a datetime.datetime</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>'iat' claim is not of type float | int | datetime.datetime</p> <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: UTC Datetime token issued date</p>"},{"location":"api/token_payload/#fastjwt.models.TokenPayload.time_since_issued","title":"<code>time_since_issued: datetime.timedelta</code>  <code>property</code>","text":"<p>Return the time elapsed since token has been issued</p> <p>Returns:</p> Type Description <code>timedelta</code> <p>datetime.timedelta: time elapsed since token has been issued</p>"},{"location":"api/token_payload/#fastjwt.models.TokenPayload.time_until_expiry","title":"<code>time_until_expiry: datetime.timedelta</code>  <code>property</code>","text":"<p>Return the time remaining until expiry</p> <p>Returns:</p> Type Description <code>timedelta</code> <p>datetime.timedelta: time remaining until expiry</p>"},{"location":"api/token_payload/#fastjwt.models.TokenPayload.decode","title":"<code>decode(token, key, algorithms=['HS256'], audience=None, issuer=None, verify=True)</code>  <code>classmethod</code>","text":"<p>Given a token returns the associated JWT payload</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token to decode</p> required <code>key</code> <code>str</code> <p>Secret to decode the token</p> required <code>algorithms</code> <code>Sequence[AlgorithmType]</code> <p>Algorithms to use to decode the token. Defaults to [\"HS256\"].</p> <code>['HS256']</code> <code>audience</code> <code>Optional[StrOrSeq]</code> <p>Audience to verify. Defaults to None.</p> <code>None</code> <code>issuer</code> <code>Optional[str]</code> <p>Issuer to verify. Defaults to None.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Enable verification. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>TokenPayload</code> <code>TokenPayload</code> <p>The decoded JWT payload</p> Source code in <code>fastjwt/models.py</code> <pre><code>@classmethod\ndef decode(\n    cls,\n    token: str,\n    key: str,\n    algorithms: Sequence[AlgorithmType] = [\"HS256\"],\n    audience: Optional[StrOrSeq] = None,\n    issuer: Optional[str] = None,\n    verify: bool = True,\n) -&gt; \"TokenPayload\":\n    \"\"\"Given a token returns the associated JWT payload\n\n    Args:\n        token (str): Token to decode\n        key (str): Secret to decode the token\n        algorithms (Sequence[AlgorithmType], optional): Algorithms to use to decode the token. Defaults to [\"HS256\"].\n        audience (Optional[StrOrSeq], optional): Audience to verify. Defaults to None.\n        issuer (Optional[str], optional): Issuer to verify. Defaults to None.\n        verify (bool, optional): Enable verification. Defaults to True.\n\n    Returns:\n        TokenPayload: The decoded JWT payload\n    \"\"\"\n    payload = decode_token(\n        token=token,\n        key=key,\n        algorithms=algorithms,\n        audience=audience,\n        issuer=issuer,\n        verify=verify,\n    )\n    return cls.parse_obj(payload)\n</code></pre>"},{"location":"api/token_payload/#fastjwt.models.TokenPayload.encode","title":"<code>encode(key, algorithm, ignore_errors=True, headers=None)</code>","text":"<p>Encode the payload</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Secret key to encode the payload</p> required <code>algorithm</code> <code>str</code> <p>Algorithm to use to encode the payload</p> required <code>ignore_errors</code> <code>bool</code> <p>Ignore validation errors. Defaults to True.</p> <code>True</code> <code>headers</code> <code>Optional[Dict[str, Any]]</code> <p>TODO. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>encoded token</p> Source code in <code>fastjwt/models.py</code> <pre><code>def encode(\n    self,\n    key: str,\n    algorithm: str,\n    ignore_errors: bool = True,\n    headers: Optional[Dict[str, Any]] = None,\n) -&gt; str:\n    \"\"\"Encode the payload\n\n    Args:\n        key (str): Secret key to encode the payload\n        algorithm (str): Algorithm to use to encode the payload\n        ignore_errors (bool, optional): Ignore validation errors. Defaults to True.\n        headers (Optional[Dict[str, Any]], optional): TODO. Defaults to None.\n\n    Returns:\n        str: encoded token\n    \"\"\"\n    # TODO Handle Headers\n    # TODO Handle Extra fields\n    return create_token(\n        key=key,\n        algorithm=algorithm,\n        uid=self.sub,\n        jti=self.jti,\n        issued=self.iat,\n        type=self.type,\n        expiry=self.exp,\n        fresh=self.fresh,\n        csrf=self.csrf,\n        audience=self.aud,\n        issuer=self.iss,\n        not_before=self.nbf,\n        ignore_errors=ignore_errors,\n        headers=headers,\n    )\n</code></pre>"},{"location":"api/token_payload/#fastjwt.models.TokenPayload.has_scopes","title":"<code>has_scopes(*scopes)</code>","text":"<p>Checks if a given scope is contained within TokenPayload scopes</p> <p>Parameters:</p> Name Type Description Default <code>*scopes</code> <code>Sequence[str]</code> <p>scopes to verify</p> <code>()</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the scopes are contained in the payload scopes</p> Source code in <code>fastjwt/models.py</code> <pre><code>def has_scopes(self, *scopes: Sequence[str]) -&gt; bool:\n    \"\"\"Checks if a given scope is contained within TokenPayload scopes\n\n    Args:\n        *scopes (Sequence[str]): scopes to verify\n\n    Returns:\n        bool: Whether the scopes are contained in the payload scopes\n    \"\"\"\n    return all([s in self.scopes for s in scopes])\n</code></pre>"},{"location":"api/types/","title":"Type Hints","text":""},{"location":"api/types/#fastjwt.types.Numeric","title":"<code>Numeric = Union[float, int]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.ObjOrSeq","title":"<code>ObjOrSeq = Union[T, Sequence[T]]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.StrOrSeq","title":"<code>StrOrSeq = ObjOrSeq[str]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.DateTimeExpression","title":"<code>DateTimeExpression = Union[datetime.datetime, datetime.timedelta]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.SymmetricAlgorithmType","title":"<code>SymmetricAlgorithmType = Literal['HS256', 'HS384', 'HS512']</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.AsymmetricAlgorithmType","title":"<code>AsymmetricAlgorithmType = Literal['ES256', 'ES256K', 'ES384', 'ES512', 'RS256', 'RS384', 'RS512', 'PS256', 'PS384', 'PS512']</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.AlgorithmType","title":"<code>AlgorithmType = Union[SymmetricAlgorithmType, AsymmetricAlgorithmType]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.HTTPMethod","title":"<code>HTTPMethod = Literal['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH']</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.HTTPMethods","title":"<code>HTTPMethods = Sequence[HTTPMethod]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.SameSitePolicy","title":"<code>SameSitePolicy = Literal['None', 'Lax', 'Strict']</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.TokenType","title":"<code>TokenType = Literal['access', 'refresh']</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.TokenLocation","title":"<code>TokenLocation = Literal['headers', 'cookies', 'json', 'query']</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.TokenLocations","title":"<code>TokenLocations = Sequence[TokenLocation]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.TokenCallback","title":"<code>TokenCallback = Callable[[str, ParamSpecKwargs], bool]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#fastjwt.types.ModelCallback","title":"<code>ModelCallback = Callable[[str, ParamSpecKwargs], Optional[T]]</code>  <code>module-attribute</code>","text":""},{"location":"callbacks/token/","title":"Token Revokation","text":"<p>For token without expiry date, or even revoked token, the standard JWT validation will pass. Hence the need to check if the token provided in request is revoked. Usually we confront the token with a blocklist of non-expired revoked token.</p> <p>FastJWT enables this revoked token check by using a custom callback system.</p>"},{"location":"callbacks/token/#setup","title":"Setup","text":"<pre><code>from typing import Optional\nfrom fastapi import FastAPI, Depends\nfrom fastjwt import FastJWT, RequestToken\n\n# This list mockups a store for bloked tokens\nREVOKED_TOKEN = []\n\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@security.set_callback_token_blocklist\ndef is_token_revoked(token:str) -&gt; bool:\n    \"\"\"Check if given token is revoked\"\"\"\n    return token in REVOKED_TOKEN\n\n# We define dependency here to avoid code repetition\nget_token_dep = security.get_token_from_request(\n    type=\"access\",\n    optional=False\n)\nget_optional_token_dep = security.get_token_from_request(\n    type=\"access\",\n    optional=True\n)\n\n@app.get(\"/login\")\ndef login():\n    token = security.create_access_token(uid=\"john.doe@fastwt.com\")\n    return {\"access_token\": token}\n\n@app.get(\"/token/optional\")\ndef get_token(token: Optional[RequestToken] = Depends(get_optional_token_dep)):\n    if token is not None\n        return f\"Your token is: {token} and is located in {token.location}\"\n    else:\n        return \"No token found\"\n\n@app.get(\"/token/mandatory\", dependencies=[Depends(security.access_token_required)])\ndef get_token(token: RequestToken = Depends(get_token_dep)):\n    return f\"Your token is: {token} and is located in {token.location}\"\n\n@app.delete(\"/logout\", dependencies=[Depends(security.access_token_required)])\ndef logout(token: RequestToken = Depends(get_token_dep)):\n    REVOKED_TOKEN.append(token.token)\n    return \"OK\"\n\n@app.get(\"/profile\", dependencies=[security.access_token_required])\ndef profile():\n    return \"You are authenticated\"\n</code></pre>"},{"location":"callbacks/token/#define-and-assign-the-callback","title":"Define and assign the callback","text":"<p>First we need to create a function with a first <code>token</code> str positional argument. This function should return <code>True</code> is the token is considered revoked, <code>False</code> otherwise.</p> <p>FastJWT provides a <code>FastJWT.set_callback_token_blocklist</code> decorator to assign a custom callback for revoked token validation.</p> <p>Once a callback is assigned with <code>FastJWT.set_callback_token_blocklist</code>, every time a valid token is required, the user defined callback is executed to check if the token is revoked.</p> <p>We define the <code>is_token_revoked</code> callback as a function taking <code>token</code> as a main str positional argument and returning a <code>bool</code></p> <p>TYPE <code>Callable[[str, ParamSpecKwargs], bool]</code> or <code>(str) -&gt; bool</code></p> <pre><code>from typing import Optional\nfrom fastapi import FastAPI, Depends\nfrom fastjwt import FastJWT, RequestToken\n\n# This list mockups a store for bloked tokens\nREVOKED_TOKEN = []\n\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@security.set_callback_token_blocklist # (1)!\ndef is_token_revoked(token:str) -&gt; bool:\n    \"\"\"Check if given token is revoked\"\"\"\n    return token in REVOKED_TOKEN\n</code></pre> <ol> <li>You can set callbacks with the <code>FastJWT</code> decorator syntax, but the following method call would also work     <pre><code>def is_token_revoked(token:str) -&gt; bool:\n    \"\"\"Check if given token is revoked\"\"\"\n    return token in REVOKED_TOKEN\n\nsecurity = FastJWT()\nsecurity.set_callback_token_blocklist(is_token_revoked)\n</code></pre></li> </ol> <p>Setting Callback syntax</p> <p>You can set callbacks with the <code>FastJWT</code> decorator syntax, but the following method call would also work <pre><code>def is_token_revoked(token:str) -&gt; bool:\n    \"\"\"Check if given token is revoked\"\"\"\n    return token in REVOKED_TOKEN\n\nsecurity = FastJWT()\nsecurity.set_callback_token_blocklist(is_token_revoked)\n</code></pre></p> Feature Proposal - Decorator Naming <p>The verbosity of <code>FastJWT.set_callback_token_blocklist</code> might encourage us to add shorter aliases in next releases</p>"},{"location":"callbacks/token/#setting-the-dependencies","title":"Setting the dependencies","text":"<p>To avoid code repetition we define callbacks as follow. This step is not necessary but allows for cleaner code. We use the <code>FastJWT.get_token_from_request</code> to create a dependency that returns a <code>fastjwt.RequestToken</code> instance.</p> <p><code>RequestToken</code> describe the JWT information contained in request. It acts as a dataclass containing a str <code>token</code>, a <code>type</code> parameter to declare the type of token expected, a <code>location</code> to define where to token is located in request and a <code>csrf</code> double submit token if necessary.</p> <pre><code># We define dependency here to avoid code repetition\nget_token_dep = security.get_token_from_request(\n    type=\"access\",\n    optional=False\n)\nget_optional_token_dep = security.get_token_from_request(\n    type=\"access\",\n    optional=True\n)\n</code></pre> <p>We created 2 dependencies, <code>get_token_dep</code> &amp; <code>get_optional_token_dep</code>, the main difference is based on the <code>optional</code> argument. </p> <p><code>get_optional_token_dep</code> return type is <code>Optional[RequestToken]</code>, meaning the execution will continue even if no token is available in request.</p> <p><code>get_token_dep</code> return type is <code>RequestToken</code>, meaning the dependency will enforce token availability in request, and raise a <code>MissingTokenError</code> otherwise.</p> <p>Note</p> <p>The <code>FastJWT.get_token_from_request</code> dependency does not check the token validity, it only returns the token if found in request. If no token appears in the request the dependency will return a <code>None</code> value.</p> <p>If you need to ensure a token is available use this dependency in conjunction with the <code>FastJWT.token_required</code> dependency</p> <pre><code>@app.get(\"/token/optional\")\ndef get_token(token: Optional[RequestToken] = Depends(get_optional_token_dep)):\n    if token is not None\n        return f\"Your token is: {token} and is located in {token.location}\"\n    else:\n        return \"No token found\"\n\n@app.get(\"/token/mandatory\", dependencies=[Depends(security.access_token_required)])\ndef get_token(token: RequestToken = Depends(get_token_dep)):\n    return f\"Your token is: {token} and is located in {token.location}\"\n</code></pre> <p>To showcase differences from the previously defined dependencies we coded 2 routes with a dummy principle, return the token and its location. </p> <p>The <code>/token/mandatory</code> endpoint depends on both <code>get_token_dep</code> as a function dependency to retrieve the token and <code>FastJWT.access_token_required</code> as a route dependency to enforce JWT validation.</p> <p>The <code>/token/optional</code> endpoint does not require a token to be passed in request, and even if a token is passed it does not need to be a valid one.</p>"},{"location":"callbacks/token/#revoke-a-token","title":"Revoke a token","text":"<p>In our example when the user request the <code>DELETE /logout</code> endpoint, we log out the user by adding the token in a blocklist. The same blocklist used to check for revoked tokens.</p> <pre><code>@app.delete(\"/logout\", dependencies=[Depends(security.access_token_required)])\ndef logout(token: RequestToken = Depends(get_token_dep)):\n    REVOKED_TOKEN.append(token.token)\n    return \"OK\"\n</code></pre> <p>Revoking Access &amp; Refresh</p> <p>If during login you generated a couple of tokens as one <code>access</code> and one <code>refresh</code> token, ensure that both tokens are revoked. Since a user can use a <code>refresh</code> token to generate new <code>access</code> tokens, revoking only the <code>access</code> token is not enough to log out the user.</p> <p>Note</p> <p>Again, even if we require <code>/logout</code> to have a token in request thanks to the <code>get_token_dep</code>, we also need to ensure this token is valid and therefore we also add the <code>FastJWT.access_token_required</code> dependency.</p> 1. Get Profile2. Get Token3. Login4. Logout5. Get Profile6. Get Token <pre><code># No credential is provided\n$ curl -s http://0.0.0.0:8000/profile\n Internal Server Error # (1)!\n</code></pre> <ol> <li>The <code>500 Internal Server Error</code> HTTP Error is the expected behavior because no error handling has been done</li> </ol> <pre><code># Endpoint with optional=True\n$ curl -s http://0.0.0.0:8000/token/optional\n\"No token found\"\n# Endpoint with optional=False\n$ curl -s http://0.0.0.0:8000/token/mandatory\nInternal Server Error # (1)!\n</code></pre> <ol> <li>The <code>500 Internal Server Error</code> HTTP Error is the expected behavior because no error handling has been done</li> </ol> <pre><code># We generate a token to be conserved\n$ curl -s http://0.0.0.0:8000/login\n{\"access_token\": $TOKEN}\n# We generate a token to be revoked\n$ curl -s http://0.0.0.0:8000/login\n{\"access_token\": $REVOKED_TOKEN}\n</code></pre> <pre><code># We call /logout with the token to be revoked\n$ curl -s --oauth2-bearer $REVOKED_TOKEN http://0.0.0.0:8000/logout\n \"OK\"\n</code></pre> <pre><code># A genuine token is provided\n$ curl -s --oauth2-bearer $TOKEN http://0.0.0.0:8000/profile\n\"You are authenticated\"\n# A revoked token is provided\n$ curl -s --oauth2-bearer $REVOKED_TOKEN http://0.0.0.0:8000/profile\nInternal Server Error # (1)!\n</code></pre> <ol> <li>The <code>500 Internal Server Error</code> HTTP Error is the expected behavior because no error handling has been done</li> </ol> <pre><code># /token/optional returns a 200 for any tokens because no validation is required\n$ curl -s --oauth2-bearer $TOKEN http://0.0.0.0:8000/token/optional\n\"Your token is: $TOKEN and is located in headers\"\n$ curl -s --oauth2-bearer $REVOKED_TOKEN http://0.0.0.0:8000/token/optional\n\"Your token is: $REVOKED_TOKEN and is located in headers\"\n\n# /token/mandatory applies a validation step\n$ curl -s --oauth2-bearer $TOKEN http://0.0.0.0:8000/token/mandatory\n\"Your token is: $TOKEN and is located in headers\"\n$ curl -s --oauth2-bearer $REVOKED_TOKEN http://0.0.0.0:8000/token/mandatory\nInternal Server Error # (1)!\n</code></pre> <ol> <li>The <code>500 Internal Server Error</code> HTTP Error is the expected behavior because no error handling has been done</li> </ol>"},{"location":"callbacks/token/#with-a-database-sqlalchemy","title":"With a database (sqlalchemy)","text":"<p>WIP</p> <p>This section is work in progress</p>"},{"location":"callbacks/user/","title":"User Serialization","text":"<p>JSON Web Tokens main purpose is authentication. While it can carry data as described in Access Payload Data, you should avoid adding to much additional data and ABSOLUTELY avoid storing sensitive information in the JWT Payload.</p> <p>Usually, JWT should carry a user/recipient/subject identifier used to retrieve required data about the user/recipient/subject.</p> <p>Given the <code>FastJWT.access_token_required</code> dependency described in Access Payload Data, you could retrieve the <code>TokenPayload</code> instance and read its <code>sub</code> claim to retrieve data from the current user. While this solution works, it increases code repetition, its error prone and it adds additional code not serving the route logic.</p> <p>To avoid code repetition, FastJWT provides a custom callback system to retrieve automatically the user data.</p>"},{"location":"callbacks/user/#get-authenticated-user-context","title":"Get authenticated user context","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastapi import FastJWT\nfrom pydantic import BaseModel\n\n# === USER STORE\n# The FAKE_DB dictionary is a mockup for\n# a user table\nFAKE_DB = {\n    \"john.doe@ocarinow.com\": {\n        \"email\": \"john.doe@ocarinow.com\",\n        \"password\": \"test\",\n        \"firstname\": \"John\",\n        \"lastname\": \"Doe\"\n    }\n}\n# === END USER STORE\n\n# === MODELS\nclass User(BaseModel):\n    email: str\n    password: str\n    firstname: str\n    lastname: str\n\nclass LoginForm(BaseModel):\n    email: str\n    password: str\n# === END MODELS\n\n\napp = FastAPI()\nsecurity = FastJWT(model=User)\n\n@security.set_subject_getter\ndef get_user_from_uid(uid: str) -&gt; User:\n    return User.parse_obj(FAKE_DB[uid])\n\n@app.post('/login')\nasync def login(data: LoginForm):\n    if FAKE_DB.get(data.email) is None:\n        raise HTTPException(401, \"Bad email/password\")\n\n    if FAKE_DB.get(data.email)[\"password\"] == data.password:\n        access_token = security.create_access_token(data.email)\n        return {\"access_token\": access_token}\n\n    raise HTTPException(401, \"Bad email/password\")\n\n@app.get('/whoami')\nasync def whoami(user: User = Depends(security.get_current_subject)):\n    return f\"\"\"You are:\n    Firstname: {user.firstname}\n    Lastname: {username.lastname}\"\"\"\n</code></pre>"},{"location":"callbacks/user/#serialization","title":"Serialization","text":"<p>Let's consider you have a user store in a form of a database. When a user authenticates itself with a JWT, you want to be able to retrieve data related to this user stored in your table.</p> <p>Example</p> <p>The snippet below simulates a database. It contains information about users</p> <pre><code># === USER STORE\n# The FAKE_DB dictionary is a mockup for\n# a user table\nFAKE_DB = {\n    \"john.doe@ocarinow.com\": {\n        \"email\": \"john.doe@ocarinow.com\",\n        \"password\": \"test\",\n        \"firstname\": \"John\",\n        \"lastname\": \"Doe\"\n    }\n}\n# === END USER STORE\n</code></pre>"},{"location":"callbacks/user/#create-the-user-object-mapper","title":"Create the User object mapper","text":"<p>First, we create a <code>pydantic.BaseModel</code> as an object mapper to describe a <code>User</code>. Note that any default python <code>typing</code> is also accepted.</p> <pre><code># === MODELS\nclass User(BaseModel):\n    email: str\n    password: str\n    firstname: str\n    lastname: str\n\nclass LoginForm(BaseModel):\n    email: str\n    password: str\n# === END MODELS\n</code></pre>"},{"location":"callbacks/user/#adding-type-hints-to-fastjwt","title":"Adding Type hints to FastJWT","text":"<p><code>FastJWT</code> is a Generic class, providing explicit type hint for the <code>model</code> argument is a good practice for development purposes.</p> <pre><code>app = FastAPI()\nsecurity = FastJWT(model=User) # (1)!\n\n@security.set_subject_getter\ndef get_user_from_uid(uid: str) -&gt; User:\n    return User.parse_obj(FAKE_DB[uid])\n</code></pre> <ol> <li> <p>You can provide type hints with multiple syntax</p> Hint by argumentHint by GenericHint by Typing <pre><code>security = FastJWT(model=User)\n</code></pre> <pre><code>security = FastJWT[User]()\n</code></pre> <pre><code>security: FastJWT[User] = FastJWT()\n</code></pre> </li> </ol> <p>Tip: Type Hint</p> <p>The <code>FastJWT</code> is a Python Generic object, you can use the <code>model</code> init parameter to enforce the type hinting. Even if you use user serialization, the <code>model</code> parameter is not mandatory, and is not used during execution except for your custom defined accessor</p> Hint by argumentHint by GenericHint by Typing <pre><code>security = FastJWT(model=User)\n</code></pre> <pre><code>security = FastJWT[User]()\n</code></pre> <pre><code>security: FastJWT[User] = FastJWT()\n</code></pre>"},{"location":"callbacks/user/#declare-the-custom-callback-for-user-retrieval","title":"Declare the custom callback for user retrieval","text":"<p>Since fetching user/recipient/subject data depends on your application logic, FastJWT provides a <code>FastJWT.set_subject_getter</code> decorator to assign a custom callback.</p> <p>We define the <code>get_user_from_uid</code> callback as a function taking <code>uid</code> as a main str positional arguemnt and returning the appropriate object for the given <code>uid</code></p> <p>TYPE <code>Callable[[str, ParamSpecKwargs], User]</code> or <code>(str) -&gt; User</code></p> <pre><code>app = FastAPI()\nsecurity = FastJWT(model=User)\n\n@security.set_subject_getter\ndef get_user_from_uid(uid: str) -&gt; User:\n    return User.parse_obj(FAKE_DB[uid])\n</code></pre> <p>Setting Callback syntax</p> <p>You can set callbacks with the <code>FastJWT</code> decorator syntax, but the following method call would also work <pre><code>def get_user_from_uid(uid: str) -&gt; User:\n    return User.parse_obj(FAKE_DB[uid])\n\nsecurity = FastJWT(model=User)\nsecurity.set_subject_getter(get_user_from_uid)\n</code></pre></p>"},{"location":"callbacks/user/#get-user-context","title":"Get User Context","text":"<p>Once the user getter callback is set, you can use the <code>FastJWT.get_current_subject</code> to obtain the parsed ORM instance. <code>FastJWT.get_current_subject</code> is also dependent on <code>FastJWT.access_token_required</code> and therefore it enforces token validation without additional dependency declaration.</p> <pre><code>@app.get('/whoami')\nasync def whoami(user: User = Depends(security.get_current_subject)): # (1)!\n    return f\"\"\"You are:\n    Firstname: {user.firstname}\n    Lastname: {username.lastname}\"\"\"\n</code></pre> <ol> <li> <p>You can use <code>FastJWT.CURRENT_SUBJECT</code> dependency alias (see Aliases)</p> <pre><code>async def whoami(user: User = security.CURRENT_SUBJECT):\n    ...\n</code></pre> </li> </ol> <p>From the <code>whoami</code> function dependency you can access the <code>User</code> instance directly and use it without having to fetch the object inside the route logic.</p> Feature - Dependency Alias <p><code>FastJWT.get_current_subject</code> might not be explicit enough and is quiet long. FastJWT provides aliases to avoid importing <code>fastapi.Depends</code>. You can use <code>FastJWT.CURRENT_SUBJECT</code> dependency alias (see Aliases)</p> <pre><code>@app.get('/whoami')\nasync def whoami(user: User = security.CURRENT_SUBJECT):\n    ...\n</code></pre> Login to get a tokenRequest the user profile <pre><code>$ curl -X POST -s \\\n    --json '{\"email\":\"john.doe@ocarinow.com\", \"password\":\"test\"}'\\\n    http://0.0.0.0:8000/login\n{\"access_token\": $TOKEN}\n</code></pre> <pre><code>$ curl -s --oauth2-bearer $TOKEN http://0.0.0.0:8000/whoami\nYou are:\n    Firstname: John\n    Lastname: Doe\n</code></pre>"},{"location":"callbacks/user/#use-a-sql-orm-sqlalchemy","title":"Use a SQL ORM (sqlalchemy)","text":"<p>WIP</p> <p>This section is work in progress</p>"},{"location":"dependencies/aliases/","title":"Dependency Aliases","text":"<p>If you are familiar with FastAPI Dependency Injection system, you know you need to import the <code>Depends</code> object to declare a dependency. Since FastJWT is designed to work with FastAPI, we provide quick aliases to get the most accessed dependencies.</p> <p>The following example demonstrate how FastJWT aliases can help you reduce verbosity.</p> Without aliasesWith aliases <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nimport fastjwt\n\napp = FastAPI()\nsecurity = FastJWT()\nsecurity.handle_errors(app)\n\n@app.route('/', dependencies=[Depends(security.access_token_required)])\ndef root(subject = Depends(security.get_current_subject), token = Depends(security.get_token_dep)):\n    ...\n</code></pre> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nimport fastjwt\n\napp = FastAPI()\nsecurity = FastJWT()\nsecurity.handle_errors(app)\n\n@app.route('/', dependencies=[security.ACCESS_REQUIRED])\ndef root(subject = security.CURRENT_SUBJECT, token = security.RAW_ACCESS_TOKEN):\n    ...\n</code></pre>"},{"location":"dependencies/aliases/#aliases","title":"Aliases","text":""},{"location":"dependencies/aliases/#access_required","title":"<code>ACCESS_REQUIRED</code>","text":"<p>Type: <code>TokenPayload</code></p> <p>Returns the access token payload if valid. Enforce the access token validation</p> Example <pre><code>from fastapi import FastAPI\nimport fastjwt\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@app.route('/protected')\ndef protected(payload = security.ACCESS_REQUIRED):\n    return f\"Your Access Token Payload is {payload}\"\n</code></pre>"},{"location":"dependencies/aliases/#access_token","title":"<code>ACCESS_TOKEN</code>","text":"<p>Type: <code>RequestToken</code></p> <p>Returns the encoded access token. DOES NOT Enforce the access token validation</p> Example <pre><code>from fastapi import FastAPI\nimport fastjwt\n\napp = FastAPI()\nsecurity = FastJWT()\n\n# Use route dependency to enforce validation in conjunction with ACCESS_TOKEN\n@app.route('/protected', dependencies=[security.ACCESS_REQUIRED])\ndef protected(token = security.ACCESS_TOKEN):\n    return f\"Your Access Token is {token}\"\n</code></pre>"},{"location":"dependencies/aliases/#refresh_required","title":"<code>REFRESH_REQUIRED</code>","text":"<p>Type: <code>TokenPayload</code></p> <p>Returns the refresh token payload if valid. Enforce the refresh token validation</p> Example <pre><code>from fastapi import FastAPI\nimport fastjwt\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@app.route('/refresh')\ndef refresh(payload = security.REFRESH_REQUIRED):\n    return f\"Your Refresh Token Payload is {payload}\"\n</code></pre>"},{"location":"dependencies/aliases/#refresh_token","title":"<code>REFRESH_TOKEN</code>","text":"<p>Type: <code>RequestToken</code></p> <p>Returns the encoded refresh token. DOES NOT Enforce the refresh token validation</p> Example <pre><code>from fastapi import FastAPI\nimport fastjwt\n\napp = FastAPI()\nsecurity = FastJWT()\n\n# Use route dependency to enforce validation in conjunction with REFRESH_TOKEN\n@app.route('/refresh', dependencies=[security.REFRESH_REQUIRED])\ndef refresh(token = security.REFRESH_TOKEN):\n    return f\"Your Refresh Token is {token}\"\n</code></pre>"},{"location":"dependencies/aliases/#fresh_required","title":"<code>FRESH_REQUIRED</code>","text":"<p>Type: <code>TokenPayload</code></p> <p>Returns the access token payload if valid &amp; FRESH. Enforce the access token validation</p> Example <pre><code>from fastapi import FastAPI\nimport fastjwt\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@app.route('/protected', dependencies=[security.FRESH_REQUIRED])\ndef protected():\n    return \"Congratulations! Your have a fresh and valid access token.\"\n</code></pre>"},{"location":"dependencies/aliases/#current_subject","title":"<code>CURRENT_SUBJECT</code>","text":"<p>Type: <code>Any</code></p> <p>Returns the current subject. Enforce the access token validation</p> <p>Note</p> <p>You must set a subject getter to use this dependency. See Custom Callbacks &gt; User Serialization</p> Example <pre><code>from fastapi import FastAPI\nimport fastjwt\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@app.route('/whoami')\ndef whoami(subject = security.CURRENT_SUBJECT):\n    return f\"You are: {subject}\"\n</code></pre>"},{"location":"dependencies/aliases/#bundle-dependency","title":"<code>BUNDLE</code> / <code>DEPENDENCY</code>","text":"<p>Type: <code>FastJWTDeps</code></p> <p>Returns the <code>FastJWTDeps</code> dependency bundle to be used within the route</p> Example <pre><code>from fastapi import FastAPI\nimport fastjwt\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@app.route('/create_token')\ndef create_token(fjwt = security.BUNDLE):\n    token = fjwt.create_access_token(uid=\"test\")\n    fjwt.set_access_cookie(token)\n    return \"OK\"\n</code></pre>"},{"location":"dependencies/bundle/","title":"Dependency Bundle","text":"<p>In order to avoid redundant or outside of logic code, FastJWT provides a way to inject a dependency bundle in route's function with <code>FastJWT.get_dependency</code>.</p> <p><code>FastJWT.get_dependency</code> returns a <code>FastJWTDeps</code> instance that is tied to the request and response of the route. This object includes all the dependency available in <code>FastJWT</code></p> <p>To show how <code>FastJWTDeps</code> can help reduce code complexity let's focus on authentication via Cookies</p> With BundleWithout Bundle <pre><code>from pydantic import BaseModel\nfrom fastapi import FastAPI, Depends\nfrom fastjwt import FastJWT, FastJWTDeps\n\napp = FastAPI()\nsecurity = FastJWT()\n\nclass LoginData:\n    username: str\n    password: str\n\n@app.post('/login')\ndef login(data: LoginData, fjwt: FastJWTDeps = Depends(security.get_dependency)):\n    if data.username == \"test\" and data.password == \"test\":\n        token = fjwt.create_access_token(uid=\"test\")\n        fjwt.set_access_cookie(token)\n        return \"CONNECTED\"\n    return \"NOT CONNECTED\"\n\n@app.post('/logout', dependencies=[Depends(security.access_token_required)])\ndef logout(fjwt: FastJWTDeps = Depends(security.get_dependency)):\n    fjwt.unset_access_cookies()\n    return \"DISCONNECTED\"\n</code></pre> <pre><code>from pydantic import BaseModel\nfrom fastapi import FastAPI, Depends\nfrom fastapi.responses import JSONResponse\nfrom fastjwt import FastJWT\n\napp = FastAPI()\nsecurity = FastJWT()\n\nclass LoginData:\n    username: str\n    password: str\n\n@app.post('/login')\ndef login(data: LoginData):\n    if data.username == \"test\" and data.password == \"test\":\n        token = security.create_access_token(uid=\"test\")\n        response = JSONResponse(status_code=200, content=\"CONNECTED\")\n        security.set_access_cookie(token, response)\n        return response\n    return \"NOT CONNECTED\"\n\n@app.post('/logout', dependencies=[Depends(security.access_token_required)])\ndef logout():\n    response = JSONResponse(status_code=200, content=\"DISCONNECTED\")\n    security.unset_access_cookies(response)\n    return response\n</code></pre> <p>The main difference in those 2 snippets is the implicit context grapped by <code>FastJWTDeps</code>. You don't need to generate get access to the request or create a response object to set/unset cookies for example. This allows for less code, but mostly prevents you to handle <code>fastapi.Response</code> objects that might be outside of your function logic.</p>"},{"location":"dependencies/deps/","title":"Main Dependencies","text":""},{"location":"dependencies/deps/#request-token-dependencies","title":"Request token dependencies","text":"<p>Sometimes, you may need to access the data relative to JWT authentication in request. such data might include, the encoded JWT, the CSRF double submit token, the location of the JWT...</p> <p>To retrieve these information from request, FastJWT provides a <code>FastJWT.get_token_from_request</code></p> <p><code>get_token_from_request</code> allow you to specify the token type you wish to retrieve with the <code>type</code> argument and to enforce the token availability with the <code>optional</code> argument</p> <pre><code>from fastjwt import FastJWT\nfrom fastjwt import RequestToken\n\nsecurity = FastJWT()\n\nTokenGetter = Callable[[Request], Awaitable[RequestToken]]\nOptTokenGetter = Callable[[Request], Awaitable[RequestToken | None]]\n\n\nget_access_from_request: TokenGetter = security.get_token_from_request(\n    type: TokenType = \"access\",\n    optional: bool = False\n)\n\nget_optional_refresh_from_request: OptTokenGetter = security.get_token_from_request(\n    type: TokenType = \"access\",\n    optional: bool = False\n)\n\n@app.get('/get_token')\nasync def get_token(token: RequestToken = Depends(get_access_from_request)):\n    ...\n</code></pre> <p>Please note that even if <code>optional</code> is set to <code>False</code>. The route will raise an error only because no token is available in request and not because the token in request has been invalidated.</p> <p><code>get_token_from_request</code> dependencies does not provide token validation. This dependency only look for token's presence in request</p>"},{"location":"dependencies/deps/#token-validation-dependencies","title":"Token validation dependencies","text":"<p>FastJWT provides 3 main dependencies for token requirements</p> <p>These methods are FastJWT properties returning a FastAPI dependency <code>Callable[[Request], TokenPayload]</code>. When these dependencies are resolved, they return a <code>TokenPayload</code></p>"},{"location":"dependencies/deps/#fastjwtaccess_token_required","title":"<code>FastJWT.access_token_required</code>","text":"<p><code>access_token_required</code> is a property returning a FastAPI dependency to enforce the presence and validity of an <code>access</code> token in request. This dependency will apply the following verification:</p> <ul> <li> JWT Validation: verify <code>exp</code>, <code>iat</code>, <code>nbf</code>, <code>iss</code>, <code>aud</code> claims</li> <li> Token type verification: <code>access</code> only</li> <li> CSRF double submit verification: if CSRF enabled and token location in cookies</li> <li> Token freshness: not required for this dependency</li> </ul>"},{"location":"dependencies/deps/#fastjwtrefresh_token_required","title":"<code>FastJWT.refresh_token_required</code>","text":"<p><code>refresh_token_required</code> is a property returning a FastAPI dependency to enforce the presence and validity of a <code>refersh</code> token in request. This dependency will apply the following verification:</p> <ul> <li> JWT Validation: verify <code>exp</code>, <code>iat</code>, <code>nbf</code>, <code>iss</code>, <code>aud</code> claims</li> <li> Token type verification: <code>request</code> only</li> <li> CSRF double submit verification: if CSRF enabled and token location in cookies</li> <li> Token freshness: not required for this dependency</li> </ul>"},{"location":"dependencies/deps/#fastjwtfresh_token_required","title":"<code>FastJWT.fresh_token_required</code>","text":"<p><code>access_token_required</code> is a property returning a FastAPI dependency to enforce the presence and validity of an <code>access</code> token in request. It also needs the token to be <code>fresh</code> This dependency will apply the following verification:</p> <ul> <li> JWT Validation: verify <code>exp</code>, <code>iat</code>, <code>nbf</code>, <code>iss</code>, <code>aud</code> claims</li> <li> Token type verification: <code>access</code> only</li> <li> CSRF double submit verification: if CSRF enabled and token location in cookies</li> <li> Token freshness: not required for this dependency</li> </ul>"},{"location":"dependencies/deps/#additional-token-dependency","title":"Additional token dependency","text":"<p>In addition to the 3 dependencies specified above, FastJWT provides <code>FastJWT.token_required</code> as an additional layer of customization for token requirements</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\nfrom fastjwt import TokenPayload\n\napp = FastAPI()\nsecurity = FastJWT()\n\naccess_token_required = security.token_required(\n    type: str = \"access\"\n    verify_type: bool = True\n    verify_fresh: bool = False\n    verify_csrf: Optional[bool] = None\n)\nfresh_token_required = security.token_required(\n    type: str = \"access\"\n    verify_type: bool = True\n    verify_fresh: bool = True\n    verify_csrf: Optional[bool] = None\n)\nrefresh_token_required = security.token_required(\n    type: str = \"refresh\"\n    verify_type: bool = True\n    verify_fresh: bool = False\n    verify_csrf: Optional[bool] = None\n)\n\nno_csrf_required = security.token_required(\n    type: str = \"access\"\n    verify_type: bool = True\n    verify_fresh: bool = False\n    verify_csrf: Optional[bool] = False\n)\n\n@app.post('/no_csrf')\ndef post_no_csrf(payload: TokenPayload = Depends(no_csrf_required)):\n    # This function is protected but does not require\n    # CSRF double submit token in case of authentication via Cookies\n    ...\n</code></pre> <p>We have regenrated the main token dependencies from the <code>FastJWT.token_required</code> method in the highlighted. <code>FastJWT.token_required</code> returns a Callable to be used as a dependency.</p> <p><code>(str, bool, bool, Optional[bool]) -&gt; Callable[[Request], TokenPayload]</code></p> <p>As a custom token validation dependency, we have created the <code>no_csrf_required</code>. This dependency requires a valid <code>access</code> token in request, but it will not execute CSRF validation if the token is located in cookies.</p> <p>WIP</p> <p>The <code>verify_csrf</code> argument is a Optional boolean to enable/disable CSRF protection. If <code>None</code> it uses the default <code>FJWTConfig.JWT_COOKIE_CSRF_PROTECT</code> setting</p>"},{"location":"dependencies/injection/","title":"Dependency Injection","text":"<p>Following the FastAPI dependency injection syntax, we can use the FastJWT dependencies in multiple places</p>"},{"location":"dependencies/injection/#route","title":"Route","text":"<p>The straightforward usage is to protect a given route. Let's consider <code>GET /protected</code> as the endpoint to protect. Depending on your need for context you might want to use FastJWT dependencies as function or route dependencies.</p> <p>If you don't need to know the user/recipient/subject context -e.g you need to display the same data to all your authenticated user regardless of who they are-</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@app.get('/protected', dependencies=[Depends(security.access_token_required)])\ndef protected(): # (1)!\n    ...\n</code></pre> <ol> <li>Used as a route dependency, it does not provide any context but only enforce authentication</li> </ol> <p>If the recipient context is needed in the route logic, you can pass the dependency to the function to retrieve a <code>TokenPayload</code> or a custom ORM object (see Custom Callbacks&gt;User Serialization)</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\nfrom fastjwt import TokenPayload\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@app.get('/protected')\ndef protected(payload: TokenPayload = Depends(security.access_token_required)): # (1)!\n    ...\n</code></pre> <ol> <li>Used as a function dependency, the return value is available as a function argument</li> </ol>"},{"location":"dependencies/injection/#application","title":"Application","text":"<p>You can also apply dependencies at an application level. It might be useful if your application is not in charge of providing authentication token but only to protect routes.</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\nfrom fastjwt import TokenPayload\n\napp = FastAPI(dependencies=[Depends(security.access_token_required)]) # (1)!\nsecurity = FastJWT()\n\n@app.get('/protected')\ndef protected(payload: TokenPayload = Depends(security.access_token_required)): # (2)!\n    ...\n\n@app.get('/protected/nocontext')\ndef protected_no_context(): # (3)!\n    ...\n</code></pre> <ol> <li>Dependencies defined here will be applied to all the routes</li> <li>You still need to apply the dependency if you need to access the token context in your route</li> <li>The route is also protected but does not need context data</li> </ol> <p>In the example above, all the application's routes require a valid access token. Note that in order to get the context in the route logic you'll have to specify the required dependency.</p> <p>Note on performance</p> <p>For routes where context is needed, it seems like the dependency is called 2 times. FastAPI creates a dependency graph and execute all the parent nodes from our selected dependency. FastAPI handles the runtime and does not execute the dependency multiple times.</p>"},{"location":"dependencies/injection/#apirouter","title":"APIRouter","text":"<p>Since adding global dependencies might be too narrow. We can use <code>fastapi.APIRouter</code> to scope a selection of route to protect under a FastJWT dependency</p> app.pyrouter.pymain.py app.py<pre><code>from fastapi import FastAPI\nfrom fastjwt import FastJWT\n\napp = FastAPI()\nsecurity = FastJWT()\n\n@app.get('/')\ndef home():\n    return \"Hello, World!\"\n</code></pre> router.py<pre><code>from fastapi import APIRouter\nfrom fastapi import Depends\n\nfrom app import security\n\nrouter = APIRouter(dependencies=[Depends(security.access_token_required)]) # (1)!\n\n@router.get('/protected'):\ndef protected():\n    return \"This is a protected endpoint\"\n</code></pre> <ol> <li>You can include the dependency in the APIRouter definition</li> </ol> main.py<pre><code>from app import app\nfrom app import security\nfrom router import router\n\napp.include_router(\n    router, \n    dependencies=[Depends(security.access_token_required)] # (1)!\n)\n</code></pre> <ol> <li>You can include the dependency in the APIRouter when including the router within the application instead of during router definition. This syntax is en EXCLUSIVE OR with regard to the one in <code>router.py</code></li> </ol>"},{"location":"dev/semver/","title":"Semantic Versioning","text":"<ul> <li>Semantic Versioning</li> <li>Commit Flow</li> <li>Commit Parser</li> <li>Tags</li> <li>Scope</li> <li>Exclamation Breaking</li> <li>Commit Message</li> <li>Additional Message</li> </ul>"},{"location":"dev/semver/#commit-flow","title":"Commit Flow","text":"<p>The Semantic Versioning is automatically trigger via GitHub Actions on the <code>main</code> branch after a merge Pull Request</p> <pre><code>%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'rotateCommitLabel': true}} }%%\ngitGraph\n    commit id: \"Current Version\" tag: \"v0.1.0\"\n    branch dev\n    commit id: \"SemVer GitHub Action\" tag: \"v0.1.1\"\n    branch dev.patch\n    commit\n    commit id: \"[FIX](scopeA) ...\"\n    checkout main\n    merge dev.patch\n    checkout dev\n    merge main\n    commit id: \"SemVer GitHub Action PATCH\" tag: \"v0.1.2\"\n    branch dev.minor\n    commit\n    commit id: \"[FEAT](scopeB) ...\"\n    checkout main\n    merge dev.minor\n    checkout dev\n    merge main\n    commit id: \"SemVer GitHub Action MINOR\" tag: \"v0.2.0\"\n    branch dev.major\n    commit\n    commit id: \"[FEAT](scopeC)! ...\"\n    checkout main\n    merge dev.major\n    checkout dev\n    merge main\n    commit id: \"SemVer GitHub Action MAJOR\" tag: \"v1.0.0\"</code></pre> <p>While a PATCH/MINOR/MAJOR modification is detected after a merge pull request from <code>dev</code> to <code>main</code> branch. You will need to merge you <code>dev</code> branch with the newly commited <code>main</code> branch to be up to date.</p>"},{"location":"dev/semver/#commit-parser","title":"Commit Parser","text":"<p>To automated the package versionning we establish the following convention for commits</p> <pre><code>[$TAG]($SCOPE)$! $COMMIT_MSG\n\n$ADDITIONAL_MESSAGE\n</code></pre>"},{"location":"dev/semver/#tags","title":"Tags","text":"<p>The Tags $TAGS described the type of commit, the following tags are allowed:</p> <ul> <li>[ADD]: Addition to the codebase</li> <li>[BREAK]/[BREAKING]: Breaking Changes</li> <li>[CI]: Commit related to CI setup</li> <li>[CONFIG]: Commit related to project configuration</li> <li>[DEBUG]: Commit related to debug events</li> <li>[DEV]: Generic Tag</li> <li>[DOC]: Commit related to Documentation</li> <li>[FEAT]: Commit related to new feature</li> <li>[FIX]: Commit related to bugfix</li> <li>[REFACTO]: Refactor without changes on features</li> <li>[RM]: Deletion to the codebase</li> <li>[TEST]: Commit related to tests</li> <li>[STYLE]: Commit related to code styling (linting/formatting)</li> </ul> <p>Multiple tags can be applied for the same commit message but only the last tag will be used to check for version bumping. We recommand to use only 1 tag or 2 MAXIMUM in case you need to explicit the content of the commit</p> <pre><code># Example 1: GOOD\n[ADD] Add __init__.py to folder\n\n# Example 2: GOOD\n[ADD][FEAT] Add new feature to codebase \n\n# Example 2: BAD\n# in this case the version bumping from [FEAT] will not be applied\n[FEAT][ADD] Add new feature to codebase \n</code></pre> <p>Some Tags are linked to version bumping:</p> <ul> <li>[FIX] will apply a PATCH versioning (e.g from x.x.2 &gt; x.x.3)</li> <li>[FEAT] will apply a MINOR versioning (e.g from x.1.2 &gt; x.2.0)</li> <li>[BREAK]/[BREAKING] will apply a MAJOR versioning (e.g from 0.1.2 &gt; 1.0.0)</li> </ul> <p>In case these tags are used in a commit you need to place tyhem as the last tag in your commit message</p>"},{"location":"dev/semver/#scope","title":"Scope","text":"<p>The Scope $SCOPE is optional but might be useful to give context about the commit</p> <pre><code># Example 1: GOOD\n[FIX](db) Correct issue with database connection\n\n# Example 2: BAD\n# Do not use whitespace in the $SCOPE\n[FIX](data base) Correct issue with database connection\n</code></pre> <p>The Scope is optional but we recommend to use it as much as possible when you can</p>"},{"location":"dev/semver/#exclamation-breaking","title":"Exclamation Breaking","text":"<p>In order to avoid the [BREAK]/[BREAKING] you can use an exclamation point $! to operate a breaking change</p> <pre><code># Example 1: GOOD\n# Use the $! operator before the :\n[ADD]! Add a breaking change to the codebase\n\n# Example 2: GOOD\n# You can use the $! operator combined with a scope \n[ADD](db)! Correct issue with database connection\n</code></pre> <p>Note: Version Bumping Priority</p> <p>In the case you commit a breaking feature you might commit a message similar to <code>[FEAT]!: COMMIT MESSAGE</code>, in this case a MAJOR bumping will be applied. As a rule of thumb the higher priority is going from MAJOR to PATCH</p> <p>Be aware that a commit message like this one <code>[DOC]!: COMMIT MESSAGE</code> will apply a MAJOR version bumbing.</p>"},{"location":"dev/semver/#commit-message","title":"Commit Message","text":"<p>The commit message $COMMIT_MSG must be a single line message to recap the main point of the commit. The commit message must be separated from the commit body by a whitespace.</p> <pre><code># Example 1: GOOD\n[ADD] Add a breaking change to the codebase\n\n# Example 2: BAD\n# You need a whitespace between the tag and the message\n[ADD]Add a breaking change to the codebase\n</code></pre>"},{"location":"dev/semver/#additional-message","title":"Additional Message","text":"<p>By applying two return after the $COMMIT_MESSAGE you can add additional text to the commit.</p> <pre><code># Example 1: GOOD\n[ADD] Add a breaking change to the codebase\\n\n\\n\nHere is an additional text paragraph that will be used by the semantic versioning and applied to change log\n</code></pre> <p>You can also use return <code>\\n</code> in the additional message</p> <pre><code># Example 2: GOOD\n[ADD] Add a breaking change to the codebase\\n\n\\n\nHere we want to display a list:\\n\n- This is a first point\\n\n- This is a second point\\n\n</code></pre> <p>Last but not least you can add specification to breaking changes in the additional text. Start a line with BREAKING CHANGE: to describe the breaking change in detail</p> <pre><code># Example 3: GOOD\n[ADD] Add a breaking change to the codebase\\n\n\\n\nHere we want to display a list:\\n\n- This is a first point\\n\n- This is a second point\\n\n\\n\nBREAKING CHANGE: The function funcA is not working anymore\\n\n\\n\nBREAKING CHANGE: The function funcB use a new argument\n</code></pre>"},{"location":"get-started/base_usage/","title":"Base Usage","text":"<p>FastJWT core concept relies in generating access tokens and protecting routes. The following examples demonstrates how to use FastJWT to quickly integrate those system within you FastAPI application.</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\nfrom fastjwt import FJWTConfig\n\napp = FastAPI(title=\"My Base App\")\n\nconfig = FJWTConfig()\nconfig.JWT_ALGORITHM = \"HS256\"\nconfig.JWT_SECRET_KEY = \"SECRET_KEY\"\n\nsecurity = FastJWT(config=config)\n\n@app.get('/login')\ndef login(username: str, password: str):\n    if username == \"test\" and password == \"test\":\n        token = security.create_access_token(uid=username)\n        return {\"access_token\": token}\n    raise HTTPException(401, detail={\"message\": \"Bad credentials\"})\n\n@app.get(\"/protected\", dependencies=[Depends(security.access_token_required)])\ndef get_protected():\n    ...\n    return \"You have access to a protected endpoint\"\n</code></pre>"},{"location":"get-started/base_usage/#setup","title":"Setup","text":"<p>Let's build our first FastAPI application with FastJWT</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\nfrom fastjwt import FJWTConfig\n\napp = FastAPI(title=\"My Base App\")\n\nconfig = FJWTConfig()\nconfig.JWT_ALGORITHM = \"HS256\"\nconfig.JWT_SECRET_KEY = \"SECRET_KEY\"\n\nsecurity = FastJWT(config=config)\n</code></pre>"},{"location":"get-started/base_usage/#create-the-fastapi-application","title":"Create the FastAPI application","text":"<p>As usual, you create your application with the <code>fastapi.FastAPI</code> object</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\nfrom fastjwt import FJWTConfig\n\napp = FastAPI(title=\"My Base App\")\n\nconfig = FJWTConfig()\nconfig.JWT_ALGORITHM = \"HS256\"\nconfig.JWT_SECRET_KEY = \"SECRET_KEY\"\n\nsecurity = FastJWT(config=config)\n</code></pre>"},{"location":"get-started/base_usage/#configure-the-jwt-behavior","title":"Configure the JWT behavior","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\nfrom fastjwt import FJWTConfig\n\napp = FastAPI(title=\"My Base App\")\n\nconfig = FJWTConfig()\nconfig.JWT_ALGORITHM = \"HS256\"\nconfig.JWT_SECRET_KEY = \"SECRET_KEY\"\n\nsecurity = FastJWT(config=config)\n</code></pre> <p>FastJWT provides a <code>FJWTConfig</code> object (pydantic's BaseSetting) to customize the behavior of JWT management. Here we enforce a symmetric encryption algorithm as <code>\"HS256\"</code> and we set the <code>SECRET_KEY</code> as the encoding/decoding key.</p>"},{"location":"get-started/base_usage/#handle-secrets","title":"Handle secrets","text":"<p>By construction, JSON Web Tokens are not encrypted, you can try your own JWT on https://jwt.io/. However, you will need secrets for your server to sign tokens.</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\nfrom fastjwt import FJWTConfig\n\napp = FastAPI(title=\"My Base App\")\n\nconfig = FJWTConfig()\nconfig.JWT_ALGORITHM = \"HS256\"\nconfig.JWT_SECRET_KEY = \"SECRET_KEY\"\n\nsecurity = FastJWT(config=config)\n</code></pre> <p>Secrets location</p> <p>As a best practice do not use explicit secrets within your code. It is recommended to use environment variables to avoid any credentials leakage <pre><code>import os\nconfig.JWT_SECRET_KEY = os.getenv(\"SECRET_KEY\")\n</code></pre></p> <p>Note on Algorithm</p> <p>For demonstration ease, we use a symmetric algorithm. Note that asymmetric algorithm offers additional layers of protection. <code>\"RS256\"</code> is the recommended algorithm when signing JWTs</p>"},{"location":"get-started/base_usage/#create-the-fastjwt-instance","title":"Create the FastJWT instance","text":"<p>You can now instantiate the <code>FastJWT</code> object with the your configuration</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\nfrom fastjwt import FastJWT\nfrom fastjwt import FJWTConfig\n\napp = FastAPI(title=\"My Base App\")\n\nconfig = FJWTConfig()\nconfig.JWT_ALGORITHM = \"HS256\"\nconfig.JWT_SECRET_KEY = \"SECRET_KEY\"\n\nsecurity = FastJWT(config=config)\n</code></pre> Loading configuration after <code>FastJWT.__init__</code> <p>The <code>config</code> argument in the <code>FastJWT.__init__</code> is optional, you can use the <code>FastJWT.load_config</code> method after initialisation to apply your configuration</p> <pre><code>config = FJWTConfig()\nconfig.JWT_SECRET_KEY = \"SECRET_KEY\"\n\nsecurity = FastJWT()\nsecurity.load_config(config)\n</code></pre>"},{"location":"get-started/base_usage/#authentication","title":"Authentication","text":""},{"location":"get-started/base_usage/#create-the-access-token","title":"Create the access token","text":"<p>To authenticate a user we create a <code>/login</code> route the usual way with FastAPI.</p> <pre><code>@app.get('/login')\ndef login(username: str, password: str):\n    if username == \"test\" and password == \"test\":\n        token = security.create_access_token(uid=username)\n        return {\"access_token\": token}\n    raise HTTPException(401, detail={\"message\": \"Bad credentials\"})\n</code></pre> <p>Once a user has provided good credentials, we use the <code>FastJWT.create_access_token</code> method to generate a signed token. To tie the user to the token, we use the <code>uid</code> argument.</p> <p>Note on PRIVACY</p> <p>Using PIDs (Personal Identification Data) should also be avoided in the JWT since its content is fully readable. As a best practice <code>uid</code> should usually be a user database index (not ordered). Check UUIDs for addtitional details.</p> <p>Note on login protection</p> <p>The <code>/login</code> route above is a dummy example. Credentials should not be carried through query paramaters. The appropriate logic should implement deeper checks with regard to authentication.</p> Request Access Token <pre><code>$ curl -s -X POST http://0.0.0.0:8000/login?username=test&amp;password=test\n {\"access_token\": $TOKEN}\n</code></pre>"},{"location":"get-started/base_usage/#protect-a-route","title":"Protect a route","text":"<p>Let's work on a simple <code>GET</code> route that can only be accessed by authenticated users.</p> <pre><code>@app.get(\"/protected\", dependencies=[Depends(security.access_token_required)])\ndef get_protected():\n    ...\n    return \"You have access to a protected endpoint\"\n</code></pre> <p>FastJWT is compliant with the FastAPI dependency injection system. It provides a <code>FastJWT.access_token_required</code> method to enforce this behavior.</p> <p>Whether we provide a bad token or no token at all, the server will forbid the route logic defined in <code>/protected</code> to be executed. </p> curl without JWTcurl with bad JWTcurl with good JWT <pre><code>$ curl -s http://0.0.0.0:8000/protected\n {\"detail\":\"Missing JWT in request\"}\n</code></pre> <pre><code>$ curl -s --oauth2-bearer \"dummytoken\" http://0.0.0.0:8000/protected\n {\"detail\":\"Unauthorized\"}\n</code></pre> <pre><code>$ curl -s --oauth2-bearer $TOKEN http://0.0.0.0:8000/protected\n \"You have access to a protected endpoint\"\n</code></pre> <p>Default exception behavior</p> <p>In the curl requests above a <code>401</code> HTTP Error is raised when the token is not valid. Without addtional setup, the expected behavior from FastJWT is an <code>500 Internal Server Error</code> HTTP Error. For ease of demonstration, we do not dive into error handling in this section.</p>"},{"location":"get-started/install/","title":"Installation","text":""},{"location":"get-started/install/#from-package-manager-prefered","title":"from package manager (prefered)","text":"pippoetrypipenv <pre><code>pip install fastjwt\n</code></pre> <pre><code>poetry add fastjwt\n</code></pre> <pre><code>pipenv install fastjwt\n</code></pre> <p>fastjwt is compatible with Python 3.9+. The current dependencies are <code>pydantic</code> and <code>pyjwt[crypto]</code>.</p> <p>Note</p> <p>The <code>pyjwt[crypto]</code> will be switched to <code>pyjwt</code> to avoid adding the <code>cryptography</code> library if not needed. Next release should allow for <code>pip install fastjwt[crypto]</code></p> <p>Note</p> <p>FastAPI, while required for fastjwt, is not declared as a dependency and must be installed prior with <code>pip install fastapi</code></p>"},{"location":"get-started/install/#from-repository","title":"from repository","text":"pippoetrypipenv <pre><code>pip install git+git://github.com/ocarinow/fastjwt.git@[branch]#egg=fastjwt\n</code></pre> <pre><code>poetry add https://github.com/ocarinow/fastjwt.git\n</code></pre> <pre><code>pipenv install git+https://github.com/ocarinow/fastjwt.git@[branch]#egg=fastjwt\n</code></pre>"},{"location":"get-started/install/#from-github","title":"from GitHub","text":"httpssshGitHub CLI <pre><code>git clone https://github.com/ocarinow/fastjwt.git\n</code></pre> <pre><code>git clone git@github.com:ocarinow/fastjwt.git\n</code></pre> <pre><code>gh repo clone ocarinow/fastjwt\n</code></pre>"},{"location":"get-started/payload_data/","title":"Access Payload Data","text":"<p>You might need to access the data from a payload in tour route logic. Let's figure how to do this with FastJWT</p> <p>FastJWT introduce a <code>TokenPayload</code> pydantic's BaseModel to handle JWT claims and operations. When FastJWt generates a token it can be serialized to an easy to use <code>TokenPayload</code> instance.</p>"},{"location":"get-started/payload_data/#storing-additional-data","title":"Storing additional data","text":"<p>By default the <code>FastJWT.create_[access|refresh]_token</code> methods handles the standard JWT claims. These claims are related to issue date, expiry time, issuer identity...</p> <p>TODO Add link to TokenPayload deep dive</p> <p>The only claim set by the user is contained in the <code>uid</code> parameter of these methods.</p> <pre><code>token = security.create_access_token(uid=\"USER_UNIQUE_IDENTIFIER\")\n</code></pre> <p>In specific cases, you might want to store additional information, to do so use you can add keyword arguments to this method as follow.</p> <pre><code>token = security.create_access_token(uid=\"USER_UNIQUE_IDENTIFIER\", foo=\"bar\")\n</code></pre> Non JSON serializable data <p>The <code>FastJWT.create_[access|refresh]_token</code> methods use the <code>json</code> package from python standard library. Therefore, additional data passed as keyword arguments must be JSON serializable.</p> <p>The snippet below will result in a <code>TypeError: Object of type datetime is not JSON serializable</code></p> <pre><code>from datetime import datetime\nsecurity.create_access_token(uid=\"USER_UNIQUE_IDENTIFIER\", foo=datetime(2023, 1, 1, 12, 0))\n</code></pre>"},{"location":"get-started/payload_data/#access-data-in-routes","title":"Access data in routes","text":"<p>JWT authentication enables scoping an endpoint logic to a given user/recipient/subject without an explicit reference to it. Following endpoint's names illustrate this concept:</p> <ul> <li> <code>/me</code></li> <li> <code>/profile</code></li> <li> <code>/user/{user_id}</code></li> </ul> <p>Since our JWT is carriying a unique identifier as <code>sub</code> claim, we can create scoped endpoint as follow.</p> <p>The <code>FastJWT.access_token_required</code> dependency can be used as a route dependency when the user context is not needed.  Used as a parameter dependency, the <code>FastJWT.access_token_required</code> will return the <code>TokenPayload</code> instance from the valid JWT. You can use this payload to retrieve data from users for example.</p> <p>While this method allows for providing user context to a route, it can lead to code repetition and force you to add fetching code that might be outside your route logic.</p> <pre><code>from fastapi import FastAPI\nfrom fastapi import Depends\n\nfrom fastjwt import FastJWT\nfrom fastjwt import TokenPayload\nfrom fastjwt import FJWTConfig\n\napp = FastAPI()\nconfig = FastJWT()\nconfig.JWT_SECRET_KEY = \"SECRET_KEY\"\nsecurity = FastJWT(config=config)\n\n@app.get('/token')\ndef get_token():\n    token = security.create_access_token(uid=\"USER_ID\", foo=\"bar\", age=22)\n    return {\"access_token\": token}\n\n@app.get('/profile')\ndef get_profile(payload: TokenPayload = Depends(security.access_token_required)):\n    return {\n        \"id\": payload.sub,\n        \"age\": getattr(payload, \"age\"),\n        \"foo\": getattr(payload, \"foo\"),\n    }\n</code></pre> <p>As usual we create the <code>FastAPI</code> application and the <code>FastJWT</code> JWT manager. We also provide a <code>GET /token</code> route to generate token.</p> <p>As in the previous section, we use the <code>FastJWT.access_token_required</code> dependency, but this time we use it a function dependency instead of a route dependency. Used in the route, <code>FastJWT.access_token_required</code> enforce the presence and validity of an <code>access</code> token in request. In addition, when used as function dependency, it returns a <code>TokenPayload</code> instance related to the token used in request.</p> <p>Whether the <code>FastJWT.access_token_required</code> dependency is used as a function argument or a route/decorator argument, it will enforce validity of the token, resulting in an exception if the token is not genuine.</p> <p>From there, you can use your <code>payload</code> object in the route logic. All the additional fields included with <code>FastJWT.create_[access|refresh]_token</code> are alos available.</p>"},{"location":"locations/cookies/","title":"JWT in Cookies","text":"<p>WIP</p> <p>This section is work in progress</p>"},{"location":"locations/headers/","title":"JWT in Headers","text":"<p>WIP</p> <p>This section is work in progress</p>"},{"location":"locations/json/","title":"JWT in JSON Body","text":"<p>WIP</p> <p>This section is work in progress</p>"},{"location":"locations/query/","title":"JWT in Query Parameters","text":"<p>WIP</p> <p>This section is work in progress</p>"}]}